### 1.强缓存

1. 浏览器端的强缓存在HTTP1.0阶段是借助Expries实现的，浏览器发送请求后，服务器端会返回一个过期时间，当达到过期时间之后，缓存的资源就会失效。
2. 在HTTP1.1阶段，使用了cache-control字段来进行资源的缓存，其中包含
   1. max-age 缓存资源过期时长
   2. public 浏览器端及代理服务器均可进行缓存
   3. private 代理服务器不能进行缓存
   4. no-cache 跳过强缓存阶段，进行协商缓存
   5. no-store 不进行缓存
   6. s-maxage 设置代理服务器的过期时间
3. cache-controal中max-age的优先级比Expries的优先级要高



### 2.协商缓存

协商缓存有两种 last-modify 和Etag

1. last-modify
   1. 是文件在服务器端发送到浏览器端时携带的日期信息，表示了当前文件的最后更新时间。
   2. 在进行协商缓存时，浏览器端会将这个时间通过if modify since请求字段带到服务器端
   3. 服务器端将这个时间和本地服务器的资源文件最后修改时间做比较，判断哪个资源较新
   4. 如果浏览器端资源是最新资源，即后续时间未对当前资源做修改，则返回304状态码，提示使用缓存文件
   5. 如果服务器端文件较新，则返回服务器端文件，并更新日期值
2. Etag
   1. Etage是根据文件内容生成的哈希值
   2. 在浏览器端与服务器端进行协商缓存时，会将这个哈希值带到服务器进行验证
   3. 如果哈希值改变，则说明浏览器端缓存过期，进行相应的更新操作
   4. 如果哈希值相同，则说明浏览器端缓存是最新的，返回304，提示使用缓存资源
3. Etag和last-modify的区别
   1. Etag因为要生成哈希值的文件，所以有性能开销
   2. 在服务器同时接收到两个时，优先使用Etag
   3. last-modify 存在的问题就是，他记录时间的最小单位是秒，如果文件在一秒内多次改变的话，那就无法检测到
   4. last-modify 存在的问题是，当文件被打开时，时间被更新，即使文件内容没有变化，实际缓存也会失效



### 3.浏览器存储

1. ##### cookie

   1. cookie设计之初是为了解决HTTP协议无状态的缺点，用于进行用户状态的管理。
   2. cookie的大小只有4kb，不足以存储大量文件。
   3. cookie会跟送域名传递，会将当前资源跟随域名发送，会造成性能浪费。
   4. 在没有设置http only字段时，为false，会给xss攻击留下可乘之机。

2. ##### sessionStorage

   1. 用于进行浏览器端的临时存储，跟随域名
   2. 大小为5MB，容量足够存储临时文件
   3. 提供便利的api，方便调用
   4. 在页面关闭后即被清除，可以存储当前页面的表单内容，历史浏览信息

3. ##### localstorage

   1. 用于浏览器端的持久化存储，跟随域名
   2. 大小为5MB，容量足够使用
   3. 提供便利的api，方便调用，且不会跟随域名被发送出去，避免了xss攻击
   4. 不手动清除永远不会失效

4. indexDB

   1. 容量无限，但目前使用率不高



### 4.输入一个URL

1. ##### 网络请求阶段

   1. 构建请求头，设置请求方法，http版本等信息
   2. 检查强缓存，如缓存命中直接返回
   3. 由于输入的是域名，域名需要经过DNS解析
   4. 查找DNS缓存，如无缓存则去获取对应IP地址
   5. 构架请求报文，包括请求方法，版本号，assept的字段，允许格式，编码方式，压缩方式
   6. 判断当前域名下TCP链接是否小于6个，如小于则继续，否则等待
   7. 建立TCP链接，三次握手阶段
   8. 如果是HTTPS协议，要进行tls握手
   9. HTTP请求建立，发送数据
   10. 接受响应，断开HTTP链接
   11. 如果TCP有keep alive属性，则不断开TCP链接，后续请求都复用这个链接

2. ##### 页面渲染阶段

   1. 如果响应报文的格式是text/html，则开始渲染阶段
   2. HTML生成dom树
   3. CSS生成样式表
   4. 二者结合生成布局树



### 5.回流和重绘

1. ##### 回流

   1. 当修改文档结构，更改dom元素属性时出现，会重新渲染dom节点，计算css样式，生成布局树，开销较大。
   2. 会引起回流的属性：
      1. 常见的几何属性：
         1. width height display top bottom left border
      2. 使dom节点发生增减、移动等情况
      3. 读写scroll、offset属性、client、属性，浏览器需要进行回流，以确保读取到的是最新的
      4. 调用window.getComponentStyle方法

2. ##### 重绘

   1. 当修改css样式时，由于不牵扯到dom节点的增减，不涉及宽高的重新计算，只用重新计算样式表，省去了计算布局的流程。

3. ##### 合成

   1. 使用css3的新特性，直接调用gpu渲染，从而提升性能
   2. 直接调用gpu渲染，跳过布局和绘制的流程



### 6.HTTPS加密流程

1. ##### 对称式加密

   1. 对称式加密步骤：
      1. 浏览器向服务器发送请求，携带加密方法列表，一个随机数a
      2. 服务器接收，返回加密方法，一个随机数b
      3. 浏览器端使用加密方法和两个随机数加密，生成密钥，最后使用这个进行通信
   2. 对称式加密存在的问题：
      1. 浏览器端请求报文可以被中间人窃取
      2. 服务器端响应报文被窃取，且得知加密方法
      3. 第三方使用窃取到的加密方法和随机数生成密钥
      4. 服务器浏览器之间通信透明

2. ##### 非对称式加密

   1. 非对称式加密步骤：
      1. 浏览器向服务器发送请求，携带加密方法列表，一个随机数a
      2. 服务器生成一个随机数b，并将公钥和加密方法返回浏览器
      3. 浏览器端使用公钥和加密方法俩个随机数生成密钥，开始通信
      4. 服务器端使用私钥进行解密
   2. 存在问题：
      1. 服务器端会将公钥返回浏览器
      2. 公钥被拦截，第三方一样可以生成密钥
      3. 浏览器服务器之间通信透明

3. ##### 结合方式

   1. 首先浏览器端发送加密方法列表，随机数a到服务器
   2. 服务器接收后返回加密方法，随机数b，公钥到浏览器
   3. 浏览器生成随机数c 配合a，b，用公钥加密，向服务器发送数据
   4. 服务器接收，用私钥解密，后续采用对称式加密，采用二者都支持的密钥加解密
   5. 因为**第三方无法获取到中间的密钥c**，不能解密密钥c，那就无法后续破解

4. ##### HTTPS

   1. https 本质上就是使用了一个数字证书的认证
   2. 在服务器返回时返回的是数字证书，浏览器在自身检索证书，如有效则得到公钥，进行后续操作
   3. 也是非对称式加密配合对称式加密的步骤。