### 工厂模式

将创建对象的过程进行封装，达到高效复用的目的。

#### 简单工厂

需求： 需要根据工厂员工的相关信息，动态创建员工的信息列表

```js
function User(name, type, age, work) {
  this.name = name;
  this.type = type;
  this.age = age;
  this.work = work;
}

function Factory(name, age, type) {
  let work;
  switch (type) {
    case 'coder':
      work = ['写代码', '写系分', '修Bug'];
      break;
    case 'product manager':
      work = ['订会议室', '写PRD', '催更'];
      break;
    case 'boss':
      work = ['喝茶', '看报', '见客户'];
    case 'xxx':
    // 其它工种的职责分配
    // ...
  }
  return new User(name, type, age, work);
}
```

#### 抽象工厂

- 开放封闭原则
  - 软件实体（类、模块、函数），可以拓展，但不可以修改。

#### 抽象工厂和简单工厂的对比

##### 共同点

都尝试去分离一个系统中变与不变的部分。区别在于场景复杂度：在简单工厂使用场景里，处理的对象是类，并且是一些易于抽离共性的类，同时因为逻辑本身比较简单，不苛求代码可拓展性。抽象工厂本质上处理的也是类，但是不易找出共性，所以需要对共性做出特别的处理，使用抽象类去降低拓展的成本，同时对类的性质进行划分。

- **抽象工厂（抽象类，不能用于生成具体实例）**用于声明最终目标产品的共性，在一个系统中，抽象工厂可以有多个，每个抽象工厂对应这一类的产品被称为‘产品族’。
- **具体工厂（用于生成产品族中的一个具体产品）**继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。
- **抽象产品（抽象类，不能用于生成具体实例）**
- **具体产品（用于生成产品族里一个具体的产品所依赖的更细粒度的产品）**