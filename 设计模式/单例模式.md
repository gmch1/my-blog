### 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点，这种模式称为单例模式。



单例模式重点在于如何才用户访问操作时，返回原先创建的对象，即多次调用new返回的都是同一个对象？

实现方式有两种，一种是类上定义的静态方法，一种是闭包

```js
// 类上定义的静态方法

class SingleDog {
  show() {
    console.log('signle');
  }
  static getInstance() {
    if (!SingleDog.instance) {
      SingleDog.instance = new SingleDog();
    }
    return SingleDog.instance;
  }
}
// 现在多次调用new 返回的都是同一个对象
SingleDog.getInstance() === SingleDog.getInstance(); // true

// 使用闭包

function SingleDog(params) {}
SingleDog.getInstance = (function () {
  let _target;
  return function () {
    if (!_target) {
      _target = new SingleDog();
    }
    return _target;
  };
})();

SingleDog.getInstance() === SingleDog.getInstance(); // true
```



#### 单例模式的实践 vuex

由于传入组件的状态树必须唯一，所以在vuex install时需要进行判断，当前vue有没有注入vuex，有的话需要抛出相应错误。



#### 单例模式面试题

##### 实现storage,单一状态树，对localstorage进行封装

```js
// 对localstorage进行封装，实现单一状态数
class Storage {
  static getInstance() {
    if (!Storage.instance) {
      Storage.instance = new Storage();
    }
    return Storage.instance;
  }
  getItem(key) {
    return localStorage.getItem(key);
  }
  setItem(key, val) {
    return localStorage.setItem(key, val);
  }
}

const storage1 = Storage.getInstance();
const storage2 = Storage.getInstance();

storage1.setItem('name', '李雷');
// 李雷
storage1.getItem('name');
// 也是李雷
storage2.getItem('name');

// 返回true
storage1 === storage2;
```

闭包版本

```js
// 先实现一个基础的StorageBase类，把getItem和setItem方法放在它的原型链上
function StorageBase () {}
StorageBase.prototype.getItem = function (key){
    return localStorage.getItem(key)
}
StorageBase.prototype.setItem = function (key, value) {
    return localStorage.setItem(key, value)
}

// 以闭包的形式创建一个引用自由变量的构造函数
const Storage = (function(){
    let instance = null
    return function(){
        // 判断自由变量是否为null
        if(!instance) {
            // 如果为null则new出唯一实例
            instance = new StorageBase()
        }
        return instance
    }
})()

// 这里其实不用 new Storage 的形式调用，直接 Storage() 也会有一样的效果 
const storage1 = new Storage()
const storage2 = new Storage()

storage1.setItem('name', '李雷')
// 李雷
storage1.getItem('name')
// 也是李雷
storage2.getItem('name')

// 返回true
storage1 === storage2
```



#### 实现全局模态框

需求：	实现全局唯一的模态框

