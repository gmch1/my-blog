### 计算属性与侦听属性

#### 计算属性

computed，通过监听某些响应式数据，从而实现动态返回一个变量，和react hooks中的effect有点类似，可以实现相同效果。

```jsx
// vue中写法
export default{
	computed:{
        name(){
            return firstName + lastName
        }
    }
}

// react hooks写法
const App = () => {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [fullName, setFullName] = useState('');
  useEffect(() => {
    setFullName(firstName + lastName);
  }, [firstName, lastName]);

  const setname = (e, type) => {
    const value = e.target.value;
    if (type === 1) {
      setFirstName(value);
    } else {
      setLastName(value);
    }
  };
  return (
    <div>
      <input onChange={(e) => setname(e, 1)}></input>
      <input onChange={(e) => setname(e)}></input>
      <div>{fullName}</div>
    </div>
  );
};
```

简单对比之后，下面开始详细的分析，vue中的计算属性。

##### 初始化

计算属性的初始化在本系列文章第一篇initState方法中就有提到，这部分逻辑定义在state.js文件中：

```js
// initState 方法调用
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  // 注意，当传入的options中有计算属性时，则进行计算属性初始化
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}

```

