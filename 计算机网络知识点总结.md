# 图解HTTP知识点总结

## 第二章.简单的HTTP协议

##### 1.URL 和 URI 的区别

URL是统一资源定位符,表明了资源所处的位置及所使用协议

URI 是统一资源标记符,不包括协议

##### 2.HTTP请求报文的构成

![image-20200716224340408](.\images\image-20200716224340408.png)

http的请求报文包括:

首行 请求协议及版本号 返回的状态码 

请求建立时间

请求体长度,请求类型

##### 3.HTTP响应报文的构成

![image-20200716224519123](images\image-20200716224519123.png)

##### 4.HTTP是无状态的协议

HTTP本身是一种不保存状态的协议，在HTTP请求过程中，协议本身不会对请求和相应数据做持久化处理。随着互联网的发展，业务需求促使HTTP1.1产生了cookie技术。

##### 5.OPTIONS请求

options请求是为了检测服务器支持的请求类型。

##### 6.HEAD请求

head请求和get请求类似，但不返回报文主体部分，用于确认URI有效性，和资源更新的时间。

##### 7.HTTP支持的请求方法

![image-20200716225250260](images\image-20200716225250260.png)

##### 8.HTTP的持久化连接

在http建立连接时，由于每一次都进行tcp的三次握手，开销较大，所以衍生出了持久化连接。

持久化连接特点，只要某一方没有说明断开链接，链接就一直继续。

在HTTP1.0之中，大多数链接都是持久化链接，这个是默认行为

##### 8.管线化

在持久化链接的基础上，建立一次TCP链接，之后可以同时发送多个请求，不必等待相应结果即可继续发生请求。

##### 9.Cookie的状态管理

HTTP是一种无状态的协议，由于用户信息鉴权的需要，所以引入了Cookie的技术，服务端通过使用setCookie即可在HTTP相应中添加相应的字段，浏览器接收到之后就会添加相应的Cookie。

#### 第三章

##### 10.HTTP报文信息

用于HTTP协议交互的被称为HTTP报文，客户端的被称为请求报文，服务端的被称为相应报文，HTTP报文本身是由多行数据构成的字符串文本。

HTTP报文大致可以分为报文首部和报文主体两块，二者由最初出现的空行来划分，通常并不一定要有报文主体。

![image-20200716230508316](images\image-20200716230508316.png)

##### 11.请求报文及相应报文的结构

![image-20200716230631650](images\image-20200716230631650.png)

![image-20200716230959392](images\image-20200716230959392.png)

#### 第四章 HTTP状态码

![image-20200716231320903](images\image-20200716231320903.png)

##### 12. 200响应

客户端发送的请求在服务器端被正常处理了。

使用get方法时，对应请求资源的实体会作为相应返回，使用head方法时，对应请求资源的实体首部不随报文主体作为相应返回。

13. ##### 204相应

    1. 服务器端接受的请求已经成功处理，但在返回的相应报文中不含实体的主体部分，浏览器发送请求处理后，返回204相应，浏览器显示的页面不发生更新。
    2. 一般只需要客户端往服务器端发送信息，而对客户端不需要发送新信息的内容下使用
    3. 例如 知乎项目中，删除数据返回204报文，删除成功。

14. ##### 206相应

    1. 服务器成功返回了部分数据，例如视频和音频数据

15. ##### 301永久重定向

    1. 请求的资源已被分配到了新的URI，以后应该使用资源现在所指的URL。

16. ##### 302临时重定向

    1. 请求的资源已经被分配了新的URI，希望本次使用新的URI访问

17. ##### 303临时重定向

    1. 与302功能大致一致，区别是明确指出使用get请求

18. ##### 304响应

    1. 与重定向关系不大
    2. 要求请求报文携带特定首部

19. ##### 307响应

    1. 临时重定向
    2. 与302功能一致
    3. 在使用时，302标准要求不能从post改成get，但是实际使用都这样做

20. ##### 400请求头错误

    1. 请求报文中存在语法错误
    2. 当错误发生时，需要修改请求的内容后再次发送请求

21. ##### 401用户鉴权失败

    1. 用户需要认证后才能进入页面
    2. 如果之前已经进行过请求，第二次进行表示用户认证失败

22. ##### 403服务器拒绝了

    1. 对请求资源的访问被服务器拒绝
    2. 拒绝原因在实体的主体部分可以看到

23. ##### 404未找到指定资源

    1. 服务器上没有找到请求的资源
    2. 服务器拒绝请求，并且不想说明理由

24. ##### 500服务器错误

    1. 服务器在执行请求时发生了错误
    2. 也有可能是web应用存在的bug或临时故障

25. ##### 503服务器异常

    1. 当前服务器超负荷或正停机维护

26. ##### HTTP请求报文

    1. ![image-20200716233316925](images\image-20200716233316925.png)
    2. ![image-20200716233401044](images\image-20200716233401044.png)

27. ##### HTTP响应报文

    1. ![image-20200716233425584](images\image-20200716233425584.png)
    2. ![image-20200716233437538](images\image-20200716233437538.png)

28. #### HTTP请求首部字段

    

    1. ##### 通用首部字段![image-20200716233557317](images\image-20200716233557317.png)

    2. ##### 请求首部字段

       ![image-20200716233717956](images\image-20200716233717956.png)

    3. ##### 相应首部字段

       ![image-20200716233834341](images\image-20200716233834341.png)
	   
     4. ##### 实体首部字段

        ![image-20200716233949803](images\image-20200716233949803.png)
    
  29. ##### Cache-Control  

        1. 用于操作缓存
        2. 缓存请求指令![image-20200716234150597](images\image-20200716234150597.png)
        3. 缓存相应指令![image-20200716234207721](images\image-20200716234207721.png)
        4. no-cache表示不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，no-store才是真正的不进行缓存
        5. express 字段表示过期的时间，由于会受到本地时间的影响，故被max-age取代
        6. max-age 设置过期时间，单位为秒，值小于0，则缓存立即失效
        7. no-transform 缓存不能改变实体主体的媒体类型

30. Accept

    1. langeage
    2. 类型
    3. 压缩方式

31. Referer

    1. 告知服务器请求的原始资源的URI

32. #### Cookie

    1. Set-Cookie相关的属性，现在还有一个sameSite属性![image-20200716235446990](images\image-20200716235446990.png)

### HTTPS



1. ##### HTTP缺陷

   1. 通信使用明文，不加密
   2. 不验证通信方身份，有可能遭遇伪装
   3. 无法证明报文的完整性，所以有可能已经遭到篡改

2. ##### 解决方案

   1. 先使用SSL建立安全通信线路，之后再这条线路上进行HTTP通信，与SSL组合使用的HTTP被称为HTTPS
   2. 对内容进行加密，把HTTP报文里所含的内容进行加密处理。

3. #### 密钥加密

   1. 共享密钥加密,也成为对称密钥加密,密钥也通过网络传输发送给接收者

   2. ##### 非对称式加密

      1. 非对称式密钥加密采用一对非对称的密钥,一把叫做私钥,一把叫做公钥,私有密钥只能自己使用,公钥可以任意发布.
      2. 使用公开密钥加密方式,发送密文的一方使用对方的公开密钥进行加密处理,对方收到被加密的消息后,再使用自己的私有密钥进行解密.利用这种方式,不需要发送用来解密的私有密钥,也就不担心密钥被窃取.

   3. ##### HTTPS采用混合加密机制

      1. HTTPS采用共享密钥加密和公开密钥加密二者并用的混合加密机制.如果密钥能实现安全交换,则可以考虑仅使用公开密钥加密来通信,但是公开密钥加密要比共享密钥加密处理速度慢

      2. 可以充分使用二者间的优势,将各种方法结合起来用于通信,在交换密钥环节使用公开密钥加密方式,之后通信交换报文阶段使用共享密钥加密方式.

      3. ![image-20200717002435374](images\image-20200717002435374.png)

      4. ##### 证明公开密钥有效性的证书

         1. 公司向数字证书认证机构申请公开密钥,判明身份后对申请的公开密钥做数字签名,并放入公钥证书进行绑定.
         2. 服务器会将公钥证书发给客户端,接到整数的客户端可以使用数字证书认证机构的公开密钥.
         3. 公开密钥是在浏览器发布时,植入浏览器内部的.![image-20200717002821766](images\image-20200717002821766.png)

#### HTTP2.0

![image-20200717003414004](images\image-20200717003414004.png)

#### 浏览器攻击

1. ##### 跨站脚本攻击 XSS

   1. 通过使用HTML标签或者JavaScript进行的一种攻击,动态创建的HTML部分可能存在安全漏洞
      1. 可以利用虚假表单窃取用户信息,
      2. 可以用脚本窃取用户的Cookie值
      3. 显示伪造的图片或文章
      4. 对字符串的转义处理
      5. 它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）

2. ##### 跨站请求伪造

   1. 在A网站登录情况下,B网站诱导你进入

   2. 如果未登录提示登录A网站

   3. B网站实际拿不到Cookie

   4. ![image-20200717004508854](images\image-20200717004508854.png)

   5. ##### 解决方法

      1. 使用token验证,token不合法则拒绝请求
      2. 将token隐藏到head头中
      3. 使用referer验证,验证页面请求来源,只接受本站请求

