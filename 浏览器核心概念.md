1. #### 进程和线程

   1. ##### 进程：
      
      1. 应用程序运行时，操作系统给其动态划分的一块内存空间，用来存放代码、运行中的数据和一个执行任务的主线程，我们称这样的一个运行环境为进程。
      2. 一个进程就是一个应用程序运行的实例。
   2. ##### 线程是进程的一部分
      
      1. 线程是依附于进程的，进程中使用多线程能够提升运行效率
      2. 进程中任一线程的崩溃都会导致进程的崩溃
      3. 线程之间共享进程中的数据
      4. 当一个进程关闭之后，操作系统会回收进程占用的内存
      5. 进程之间的内容相互隔离

2. #### 单进程浏览器时代

   1. ##### 浏览器所有功能模块都是运行在同一个进程里
      
      1. 浏览器上任一线程崩溃都会导致浏览器进程崩溃
      2. 页面渲染，网络请求，JavaScript运行环境，插件都是运行在一个线程中的，不稳定性增大
      3. 线程间数据是共享的，如果有第三方插件窃取数据，浏览器安全性较差

3. #### 多进程浏览器时代

   1. ##### 进程分类

      1. 插件进程
      2. 渲染进程
         1. 解析、渲染、执行JavaScript、合成网页图片
         2. 运行在沙箱里，不能读写硬盘上的数据，不能获取操作系统的读写权限
      3. 浏览器主进程
         1. 下载资源、管理IPC、显示渲染进程生成的图片

   2. ##### 问题解决

      1. 不稳定问题

         1. 进程间相互隔离，不同进程无法获取其他进程数据，一个进程崩溃不会牵连其他进程

      2. 不流畅问题

         1. JavaScript是运行在渲染进程中的，当JavaScript死循环时，受影响的仅有当前页面，其他页面在不同的进程中，故不会受到影响
         2. 页面关闭时，相应的渲染进程随之关闭，操作系统进行内存回收，由此解决内存泄漏问题。

      3. 安全问题

         1. 使用安全沙箱，在沙箱中运行的程序无法访问硬盘，也无法去访问系统权限。

   3. ##### 当前架构

      1. 渲染进程
         
         1. 负责进行HTML CSS JS 的渲染执行，每个Tab标签都有单独的渲染进程，都处于沙箱环境下运行。
         
      2. 插件进程
         
         1. 负责插件的运行，进行插件环境的隔离，避免插件崩溃影响浏览器渲染
         
      3. 网络进程
         
         1. 负责页面网络资源的加载
         
      4. 浏览器主进程
         
         1. 界面显示、用户交互、子进程管理，提供存储等功能
         
      5. GPU 进程
         
         1. 3D图形绘制
         
      6. ###### 存在问题

         1. 更高的资源占用，每个进程都会包含公共基础结构的副本，如JavaScript运行环境
         2. 更复杂的体系结构，浏览器各模块间耦合性高，现有架构很难去支持新特性，适应新需求

   4. ##### 面向未来的架构

      1. 将原先的模块重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须采用预定义好的接口，通过IPC来通信，从而构建一个**更内聚、低耦合、易于维护和拓展的系统**
      2. chrome面向服务的架构图，现在已经实现了一部分![image-20200724201640024](C:\Users\22\Desktop\笔记\images\image-chrome面向服务的架构图.png)

   5. #### TCP/UDP/IP

      1. ##### IP

         1. IP协议位于网络层，接收上层传下来的数据并加上IP头，IP头包含了目的主机的信息和发送方的信息

      2. ##### HTTP

         1. HTTP协议位于应用层，将接受的信息传递到网络层

      3. ##### TCP/UDP

         1. TCP/UDP位于传输层，将HTTP报文加上TCP/UDP首部之后传递到网络层，网络层IP协议再再此基础上加上IP首部

   6. #### 浏览器渲染的几个阶段

      1. 加载HTML、JavaScript、CSS

      2. 渲染流水线

         1. 构建dom树
         2. 样式计算
         3. 布局阶段
         4. 分层
         5. 绘制
         6. 光栅化
         7. 合成

      3. ##### 构建dom树

         1. 构建dom树的输入内容是HTML文本，由HTML解析器解析，最终输出的是树状的dom

      4. ##### 样式计算

         目的是计算出每个dom节点的具体样式

         1. 将CSS转换为浏览器能够理解的结构styleSheets
         2. 转换样式表中的属性值，使其标准化
         3. 计算出dom树中每个节点的具体样式

      5. ##### 布局阶段

         计算dom树中可见元素的几何位置

         1. 创建只包含可见元素的布局树
         2. 布局计算

      6. ##### 分层

         因为页面中还包含有很多的复杂效果，如一些3d变换，页面滚动，或者使用z-index进行z轴排序等，为了更加方便的实现这类效果，渲染引擎还需要为特定节点生成专用的图层，并生成一颗对应的图层树。

         1. 拥有层叠上下文属性的元素会被提升为单独的一层 z-index
         2. 需要剪裁的地方也被创建为图层 文本溢出

      7. ##### 图层绘制

      8. ##### 栅格化操作

         绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。![image-20200725150905560](C:\Users\22\Desktop\笔记\images\image-渲染.png)

         1. 当图层的绘制列表准备好后，主线程会把该绘制列表**提交**给合成线程。

         2. 合成线程将图层划分为图块，之后按照视口附近的图块来优先生成位图，实际上生成位图的操作是由栅格化来执行的。栅格化是指将图块转换为位图。图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有图形栅格化都是在线程池内执行的，运作方式如下：![image-20200725151314953](C:\Users\22\Desktop\笔记\images\image-栅格化.png)

         3. 栅格化过程会使用GPU进行加速生成，使用GPU生成位图的过程叫做快速栅格化，生成的位图被保存在GPU内存中。

         4. 因为GPU操作是在GPU进程中完成，如歌栅格化过程使用了GPU，那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作![image-20200725151632246](C:\Users\22\Desktop\笔记\images\image-GPU栅格化.png)渲染进程把⽣成图块的指令发送给GPU，然后在GPU中执⾏⽣成图块的位图，并保存在 GPU的内存中。 

         5. 合成和显示

            ⼀旦所有图块都被光栅化，合成线程就会⽣成⼀个绘制图块的命令----“DrawQuad”，然后将该命令提交 给浏览器进程。 浏览器进程⾥⾯有⼀个叫viz的组件，⽤来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命 令，将其页面内容绘制到内存中，最后再将页面内容显示在屏幕上。

      9. ##### 渲染流程总结

         ![image-20200725152027066](C:\Users\22\Desktop\笔记\images\image-渲染流程总结.png)

         1. 渲染进程将HTML内容转换为能够读懂的DOM树结构。
         2. 渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。
         3. 创建布局树，并计算元素的布局信息。
         4. 对布局树进行分层，并生成分层树。
         5. 为每个图层生成绘制列表，并将其提交到合成线程。
         6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
         7. 合成线程发送绘制图块命令DrawQuad给浏览器进程。
         8. 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上。

   7. #### 重排、重绘、合成的概念

      1. ##### 更改了元素的几何属性 --- 重排

         ![image-20200725154313363](C:\Users\22\Desktop\笔记\images\image-重排.png)

         如果使用JavaScript或者CSS修改了元素的几何位置属性，如改变元素高度、宽度等，浏览器会触发重新布局，解析之后一系列的子阶段，这个过程被称为重拍。重拍需要更新完整的渲染流水线，所以开销也是最大的。

      2. ##### 更新元素的绘制属性 ---重绘

         例如通过JavaScript更新某些元素的背景颜色。

         ![image-20200725154552964](C:\Users\22\Desktop\笔记\images\image-重绘.png)

         如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为没有引起几何位置的变化，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率比重拍操作要高一些。

      3. ##### 直接合成阶段

         如果更改一个不需要布局也不需要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程称为合成。

         ![image-20200725154907935](C:\Users\22\Desktop\笔记\images\image-直接合成.png)

         在上图中，我们使用了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制的两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

   8. #### 变量提升

      1. JavaScript代码执行过程中，需要先做变量提升，而之所以需要变量提升，是因为JavaScript执行之前需要先编译。
      2. 在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为undefined；在代码执行阶段，JavaScript引擎会从变量环境中去查找自定义的变量和函数。
      3. 如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义那个，这是因为后定义的会覆盖掉之前定义的。

   9. #### 调用栈

      这部分建议观看冴羽老师博客 --- <a style="color:#666" href="https://github.com/mqyqingfeng/Blog">传送门</a>

   10. #### 块级作用域

       1. let 执行上下文

          ![image-20200725204428572](.\images\image-let执行上下文.png)

          1. 编译并创建执行上下文
             1. 函数内部通过var生命的变量，在编译阶段全都被存放到变量环境中。
             2. 通过let生命的变量，在编译阶段会被存放到词法环境中。
             3. 在函数的作用域内部，通过let声明的变量并没有被存放到词法环境中。
          2. 继续执行代码，当执行到代码块里，变量环境中的a的值已经被设置成了1，此法环境中的值已经被设置成了2。
          3. 当进入函数的作用域时，作用域块中通过let声明的变量，会被存放在词法环境一个单独的区域当中，这个区域的变量并不影响作用域块外面的变量，当执行到作用域内部时，同名变量都是单独的存在。
          4. 在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压倒栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。
          5. 当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量a的值，具体查找方式是：沿着词法环境的栈顶向下查询，如果在此法环境中的某个块查到了，就直接返回给JavaScript引擎，如果没有查到，那么就继续在变量环境中查找。![image-20200725210000665](C:\Users\22\Desktop\笔记\images\image-变量环境查找.png)
          6. 当作用域块执行完成之后，其内部定义的变量就会从词法环境的栈顶弹出。

   11. #### 作用域链和闭包

       1. ##### 作用域链

          ![image-20200725215113321](C:\Users\22\Desktop\笔记\images\image-执行上下文案例.png)

          1. 每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。
          2. 当一段代码使用了一个变量时，JavaScript引擎首先会在“当前的执行上下文”中查找该变量，比如上面那段代码在查找myName变量时，如果在当前的变量环境中没有查找到，那么JavaScript引擎会继续在outer所指向的执行上下文中查找。![image-20200725215154332](C:\Users\22\Desktop\笔记\images\image-作用域链.png)
          3. 从图中可以看出，bar函数和foo函数的outer都是指向全局上下文的，这就意味着如果在bar函数或者foo函数中使用了外部变量，那么JavaScript引擎就会去全局执行上下文中查找，我们把这个查找的链条就称为作用域链。

       2. ##### 词法作用域

          词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

          ![image-20200725215712176](C:\Users\22\Desktop\笔记\images\image-词法作用域.png)

          1. 词法作用域就是根据代码的位置来决定的，其中main函数包含了bar函数，bar函数包含了foo函数，所以整个词法作用域的顺序是：foo函数作用域--bar函数作用域--main函数作用域--全局作用域。
          2. 根据词法作用域，foo和bar的上级作用域都是全局作用域，所以如果foo或bar使用了一个它们没有定义的变量，那么它们回到全局作用域去查找。也就是说：**词法作用域是代码阶段就定义好的，和函数怎么调用没有关系。**

       3. ##### 块级作用域中的变量查找

          ![image-20200725221127910](C:\Users\22\Desktop\笔记\images\image-块级作用域的变量查找.png)

          1. 首先在bar的作用域中查找，检查词法环境，检查变量环境
          2. 在全局作用域查找，检查词法环境，检查变量环境![image-20200725221310262](C:\Users\22\Desktop\笔记\images\image-块级作用域变量查找.png)

       4. ##### 闭包

          在JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把使用这些自由变量的函数称为闭包。

       5. ##### 闭包回收

          1. 通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但是如果这个闭包以后不再使用的话，就会造成内存泄漏。
          2. 如果引用闭包的函数是个局部变量，等函数销毁后，在下次JavaScript引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么JavaScript引擎的垃圾回收器就会回收这块内存。

   12. #### this

       1. 当函数作为对象的方法调用时，函数中的this就是该对象。
       2. 当函数被正常调用时，在严格模式下，this的值是undefined，非严格模式下this指向是全局对象window。
       3. 嵌套函数中的this不会继承外部函数中的this。
       4. 构造函数创建的实例对象，this指向new出来的对象。
       5. call apply bind可以改变this指向。

   13. #### 堆栈空间与数据存储

       1. ##### 栈内存

          1. 原始类型的数据都是直接保存在“栈”中的，引用类型数据的值是存放在“堆”中的。
          2. JavaScript引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了的话，所有的数据都存储在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。例如一个函数执行完成之后，JavaScript引擎需要离开当前执行的上下文，只需要将指针移动到上个上下文的地址就可以了，之前函数的执行上下文栈空间被全部回收。![image-20200725235627534](C:\Users\22\Desktop\笔记\images\image-栈空间回收.png)
          3. 所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆内存空间很大，缺点是分配内存和回收内存会占用一定的时间。
          4. 原始类型的赋值会完整复制变量值，引用类型的赋值是赋值引用地址。

       2. ##### 闭包

          ```js
          function foo(){
              var myName =  'hello'
              let test1 = 1
              const test2 = 2
              var innerBar = {
                  setName : function(){
                      console.log(test1)
                      return myName
                  },
                  getName : function(){
                      console.log(test1)
                      return myName
                  }
              }
              return innerBar
          }
          var bar = foo()
          bar.setName('aaa')
          bar.getName()
          console.log(bar.getName())
          ```

          

          1. 当JavaScript引擎执行到foo函数时，首先会编译，并创建一个空执行上下文。
          2. 在编译过程中，遇到内部函数setName，JavaScript引擎还要堆内部函数做一次快速的词法扫描，发现该内部函数引用了foo函数中的myName变量，由于是内部函数引用了外部函数的变量，所以JavaScript引擎判断这是一个闭包，于是在堆内存空间创建一个“closure(foo)”对象（这是一个内部对象，JavaScript是无法访问的），用来保存myName变量。
          3. 接着继续扫描到getName方法时，发现该函数内部还引用变量test1，于是JavaScript引擎又将test1添加到“closure(foo)”对象中。这时候堆内存中的“closure(foo)”对象中就包含了myName和test1两个变量。
          4. 由于test2并没有被函数引用，所以test2依然保存在调用栈中。![image-20200726002203949](C:\Users\22\Desktop\笔记\images\image-闭包产生过程.png)
          5. 当执行到foo函数时，闭包就产生了；当foo函数执行结束之后，返回的getName和setName方法都引用“closure(foo)”对象，所以即使foo函数退出了，“closure(foo)”依然被其内部的getName和setName方法引用。所以在下次调用bar.setName或者bar.getName时，创建的执行上下文中就包含了“closure(foo)”。
          6. 总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二部是把内部函数引用的外部变量保存到堆中。

   14. #### 垃圾回收 ----栈内存回收

       ```js
       // 以如下代码为例
       function foo(){
           var a = 1
           var b = {name:'极客邦'}
           function showName(){
               var c = '极客时间'
               var d = {name:'极客时间'}
           }
           showName()
       }
       foo()
       ```

       

       1. 当执⾏到第6⾏代码时，其调⽤栈和堆空间状态图如下所示：![image-20200726153018380](C:\Users\22\Desktop\笔记\images\image-堆栈示意图.png)

       2. 从图中可以看出，原始类型的数据被分配到栈中，引用类型的数据会被分配到堆中。当foo函数执行结束之后，foo函数的执行上下文会从堆中被销毁掉。

          ​	如果执行到showName函数时，那么JavaScript引擎会创建showName函数的执行上下文，并将showName函数的执行上下文压入到调用栈中，最终执行到showName函数时，其调用栈就如上图所示。与此同时还有一个**记录当前执行状态的指针（称为ESP）**指向调用栈中showName函数的执行上下文，表示当前正在执行的showName函数。

          ​	当showName函数执行完成之后，函数执行流程就进入了foo函数，这时就需要销毁showName函数的执行上下文。JavaScript会将ESP下移到foo函数的执行上下文，**这个下移操作就是销毁showName函数执行上下文的过程。**

          ![image-20200726153615921](C:\Users\22\Desktop\笔记\images\image-函数执行上下文销毁.png)

          从图中可以看出，当showName函数执行结束之后，ESP向下移动到foo函数的执行上下文中，上面showName的执行上下文虽然保存在栈内存中，但已经是无效内存了。比如当foo函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。

          所以说，当一个函数执行结束之后，**JavaScript引擎会通过下移ESP指针来销毁该函数保存在栈中的执行上下文。**

   15. #### 垃圾回收 ---堆内存回收

       当上面一段代码执行完毕之后，ESP是指向全局上下文的，showName函数和foo函数的执行上下文就处于无效状态了，不过保存在堆内存中的两个对象依然占用着空间，如下图所示：![image-20200726154110018](C:\Users\22\Desktop\笔记\images\image-foo函数执行完成后的内存状态.png)

       **要回收这一部分内存，就需要用到JavaScript中的垃圾回收器。**

       1. ##### 代际假说和分代收集

          1. ###### 代际假说有以下两个特点：

             1. 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就不可访问。
             2. 第二个是不死的对象，会活的更久。

          2. ###### 在v8引擎中，会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的是生存时间久的对象。

             1. 新生区通常只支持1-8M的容量，老生代的容量就大很多了。对于这两块区域，V8分别使用两个不同的垃圾回收器，以便更高效的实施垃圾回收。
             2. 副垃圾回收器，主要负责新生代的垃圾回收。
             3. 主垃圾回收器，主要负责老生代的垃圾回收。

       2. ##### 垃圾回收器的工作流程

          **不管是什么类型的垃圾回收器，它们都有一套共同的执行流程。**

          1. 标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
          2. 回收非活动对象占用的内存。其实就是在标记完成之后，统一清理内存中所有被标记为可回收的对象。
          3. 做内存整理。一般来说，频繁回收对象之后，内存中会存在大量不连续空间，我们把这些不连续的内存空间称为**内存碎片**。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存时候，就有可能出现内存不足的情况。所以最后一部需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收不会产生内存碎片，比如副垃圾回收器。

       3. ##### 副垃圾回收器

          副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都被分配到新生区，所以这个区域虽然不大，但是垃圾回收还是比较频繁的。

          新生代中使用Scavenge算法来处理。所谓Scavenge算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域![image-20200726162532012](C:\Users\22\Desktop\笔记\images\image-V8的堆空间.png)

          新加入的对象都会存放到对象区域，当对象区域快写满时，就需要执行一次垃圾清理工作。

          1. 在垃圾回收过程中，首先要堆对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些仍存活的对象复制到空闲区域中，同时它还会把这些对象有序的排列起来，使用这个复制过程也完成了内存整理工作，复制后空闲区域就没有内存碎片了。
          2.  完成复制后对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成对象区域。这样就完成了垃圾对象的回收操作，同时**这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。**
          3. 由于新生代采用的Scavenge算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空间区域。但复制操作需要时间成本，如果新⽣区空间设置得太大了，那么每次清理的时间就会过久，所以**为了执行效率，⼀般新生区的空间会被设置得比较小。** 
          4. 也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript引擎采用了**对象晋升策略**，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

       4. ##### 主垃圾回收器

          主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会被直接分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。

          由于老生区的对象比较大，若要在老生区中使用Scavenge算法进行垃圾回收，复制这些大对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而主垃圾回收器是采用**标记-清除**的算法进行回收的。

          1. 首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个便利过程总，能够达到的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。如果堆内存中的元素找不到栈内存中的引用，那就说明它是垃圾数据。
          2. 接下来就是垃圾的清除过程。这个过程和副垃圾回收器的垃圾清除过程有很大不同。![image-20200726165442308](C:\Users\22\Desktop\笔记\images\image-垃圾清除.png)
          3. 上⾯的标记过程和清除过程就是标记-清除算法，不过对⼀块内存多次执⾏标记-清除算法后，会产⽣⼤量不 连续的内存碎⽚。⽽碎⽚过多会导致⼤对象⽆法分配到⾜够的连续内存，于是⼜产⽣了另外⼀种算法⸺标 记-整理（Mark-Compact） 记-整理（Mark-Compact），这个标记过程仍然与标记-清除算法⾥的是⼀样的，但后续步骤不是直接对可回收对象进⾏清理，⽽是让所有存活的对象都向⼀端移动，然后直接清理掉端边界以外的内存。你可以参考下图：![image-20200726165535308](C:\Users\22\Desktop\笔记\images\image-标记整理.png)

       5. ##### 全停顿

          由于JavaScript是运行在主线程之上，一旦执行垃圾回收算法，都需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕之后再恢复脚本执行。我们把这种行为叫做**全停顿**。

          比如堆中的数据有1.5GB，V8实现一次完整的垃圾回收需要1秒以上的时间，这也是由于垃圾回收而引起JavaScript线程暂停执行的时间，若是这样的时间花销，那么应用的性能和相应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图：![image-20200726165927165](C:\Users\22\Desktop\笔记\images\image-全停顿.png)

          在V8新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿影响不大，但是老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上⾯图⽚展⽰的那样，花费了200毫秒，在 这200毫秒内，主线程是不能做其他事情的。⽐如⻚⾯正在执⾏⼀个JavaScript动画，因为垃圾回收器在工作，就会导致这个动画在这200毫秒内⽆法执⾏的，这将会造成页面的卡顿现象。

          为了降低老生代的垃圾回收而造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替执行，直到标记阶段完成，我们把这个算法称为增量标记算法。![image-20200726170327866](C:\Users\22\Desktop\笔记\images\image-增量标记算法.png)

          使用增量标记算法，可以把一个完整的垃圾回收任务拆分成很多小的任务，这些小的任务执行时间比较段，可以穿插在其他的JavaScript任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。

   16. #### 编译器和解释器

       1. ##### 编译器和解释器

          1. 编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。
          2. 解释型语言编写的程序，在每一次运行时都需要经过解释器对程序进行动态解释和执行。![image-20200726192957722](C:\Users\22\Desktop\笔记\images\image-编译器和解释器.png)
          3. 执行流程
             1. 在编译型语言的编译过程中，编译器首先会一次对源代码进行词法分析，语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。
             2. 在解释型语言的解释过程总，同样解释器也会对源代码进行词法分析，语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。

       2. ##### V8的执行流程

          V8执行一段代码的流程![image-20200726193400639](C:\Users\22\Desktop\笔记\images\image-V8执行一段代码的流程.png)

          1. ###### 将源代码转换为抽象语法树，并生成执行上下文，执行上下文主要是代码执行过程中的环境信息。

             **概念**

             AST抽象语法树和代码的结构非常相似，即代码的结构化的表示，编译器或解释器后续的工作都需要依赖于AST，而不是源代码

             AST作为一种非常重要的数据结构，再很多项目中有着广泛的应用。

             例如：**Babel**，Babel作为一个被广泛使用的代码转换器，可以将ES6代码转换为ES5代码；Babel的原理就是先将ES6源代码转换为AST，然后将ES6语法的AST转换为ES5语法的AST，最后根据AST来生成JavaScript源代码。

             **ESLint**也使用AST，ESLint是一个用来检查JavaScript编写规范的插件，其检测流程也是将源代码转换为AST，然后利用AST来检查代码规范化问题。

             ###### 第一阶段是分词，又称为词法分析

             其作用是将一行行的源码拆解成一个个token。所谓token是指语法上不可能再分的、最小的单个字符或者字符串。![image-20200726194217718](C:\Users\22\Desktop\笔记\images\image-token示意图.png)

             ###### 第二阶段是解析，又称为语法分析

             其作用是将上一步生成的token数据，根据语法规则转为AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在错误，这一步就会终止，并抛出一个语法错误。

             这就是AST的生成过程，先分词，再解析。

             有了AST之后，V8就会生成该代码的执行上下文。

             

          2. ##### 生成字节码

             有了AST和执行上下文后，接下来解释器根据AST生成字节码，并解释执行字节码。

             **字节码就是介于AST和机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。**![image-20200726200511981](C:\Users\22\Desktop\笔记\images\image-字节码机器码占用空间对比.png)

          3. ##### 执行代码

             通常如果有一段第一次执行的字节码，解释器就会逐条解释执行。在执行字节码的过程中，如果发现热点代码，比如一段代码被重复执行多次，那么后台的编译器就会把该段热点代码的字节码编译成更为高效的机器码，之后再执行这段被优化的代码时，只需执行编译后的机器码就可以了，从而提升代码的执行效率。

             **即时编译**![image-20200726200959918](C:\Users\22\Desktop\笔记\images\image-即时编译.png)

             

       3. ##### JavaScript的性能优化

          1. 提升单次脚本的执行速度，避免JavaScript的长任务霸占主线程，使页面快速响应交互
          2. 避免大的内联脚本（同步脚本），在解析HTML的过程中，解析和编译也会占用主线程
          3. 减少JavaScript文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。

          

   17. #### 消息队列和事件循环

       1. ##### 消息队列

          **消息队列是一种数据结构，可以存放需要执行的任务，它符合队列”先进先出“的特点。**

          ![image-20200726213231142](C:\Users\22\Desktop\笔记\images\image-消息队列.png)
          
       2. ##### 宏任务、微任务、

          通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果DOM有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。

          当宏任务中的主要功能都直接完成之后，渲染引擎执行当前宏任务中的微任务，因为DOM变化的事件都保存在这些微任务队列中，这样也就解决了实时性的问题。





   ​              
