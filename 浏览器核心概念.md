1. #### 进程和线程

   1. ##### 进程：
      
      1. 应用程序运行时，操作系统给其动态划分的一块内存空间，用来存放代码、运行中的数据和一个执行任务的主线程，我们称这样的一个运行环境为进程。
      2. 一个进程就是一个应用程序运行的实例。
   2. ##### 线程是进程的一部分
      
      1. 线程是依附于进程的，进程中使用多线程能够提升运行效率
      2. 进程中任一线程的崩溃都会导致进程的崩溃
      3. 线程之间共享进程中的数据
      4. 当一个进程关闭之后，操作系统会回收进程占用的内存
      5. 进程之间的内容相互隔离

2. #### 单进程浏览器时代

   1. ##### 浏览器所有功能模块都是运行在同一个进程里
      
      1. 浏览器上任一线程崩溃都会导致浏览器进程崩溃
      2. 页面渲染，网络请求，JavaScript运行环境，插件都是运行在一个线程中的，不稳定性增大
      3. 线程间数据是共享的，如果有第三方插件窃取数据，浏览器安全性较差

3. #### 多进程浏览器时代

   1. ##### 进程分类

      1. 插件进程
      2. 渲染进程
         1. 解析、渲染、执行JavaScript、合成网页图片
         2. 运行在沙箱里，不能读写硬盘上的数据，不能获取操作系统的读写权限
      3. 浏览器主进程
         1. 下载资源、管理IPC、显示渲染进程生成的图片

   2. ##### 问题解决

      1. 不稳定问题

         1. 进程间相互隔离，不同进程无法获取其他进程数据，一个进程崩溃不会牵连其他进程

      2. 不流畅问题

         1. JavaScript是运行在渲染进程中的，当JavaScript死循环时，受影响的仅有当前页面，其他页面在不同的进程中，故不会受到影响
         2. 页面关闭时，相应的渲染进程随之关闭，操作系统进行内存回收，由此解决内存泄漏问题。

      3. 安全问题

         1. 使用安全沙箱，在沙箱中运行的程序无法访问硬盘，也无法去访问系统权限。

   3. ##### 当前架构

      1. 渲染进程
         
         1. 负责进行HTML CSS JS 的渲染执行，每个Tab标签都有单独的渲染进程，都处于沙箱环境下运行。
         
      2. 插件进程
         
         1. 负责插件的运行，进行插件环境的隔离，避免插件崩溃影响浏览器渲染
         
      3. 网络进程
         
         1. 负责页面网络资源的加载
         
      4. 浏览器主进程
         
         1. 界面显示、用户交互、子进程管理，提供存储等功能
         
      5. GPU 进程
         
         1. 3D图形绘制
         
      6. ###### 存在问题

         1. 更高的资源占用，每个进程都会包含公共基础结构的副本，如JavaScript运行环境
         2. 更复杂的体系结构，浏览器各模块间耦合性高，现有架构很难去支持新特性，适应新需求

   4. ##### 面向未来的架构

      1. 将原先的模块重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须采用预定义好的接口，通过IPC来通信，从而构建一个**更内聚、低耦合、易于维护和拓展的系统**
      2. chrome面向服务的架构图，现在已经实现了一部分![image-20200724201640024](C:\Users\22\Desktop\笔记\images\image-chrome面向服务的架构图.png)

   5. #### TCP/UDP/IP

      1. ##### IP

         1. IP协议位于网络层，接收上层传下来的数据并加上IP头，IP头包含了目的主机的信息和发送方的信息

      2. ##### HTTP

         1. HTTP协议位于应用层，将接受的信息传递到网络层

      3. ##### TCP/UDP

         1. TCP/UDP位于传输层，将HTTP报文加上TCP/UDP首部之后传递到网络层，网络层IP协议再再此基础上加上IP首部

   6. #### 浏览器渲染的几个阶段

      1. 加载HTML、JavaScript、CSS

      2. 渲染流水线

         1. 构建dom树
         2. 样式计算
         3. 布局阶段
         4. 分层
         5. 绘制
         6. 光栅化
         7. 合成

      3. ##### 构建dom树

         1. 构建dom树的输入内容是HTML文本，由HTML解析器解析，最终输出的是树状的dom

      4. ##### 样式计算

         目的是计算出每个dom节点的具体样式

         1. 将CSS转换为浏览器能够理解的结构styleSheets
         2. 转换样式表中的属性值，使其标准化
         3. 计算出dom树中每个节点的具体样式

      5. ##### 布局阶段

         计算dom树中可见元素的几何位置

         1. 创建只包含可见元素的布局树
         2. 布局计算

      6. ##### 分层

         因为页面中还包含有很多的复杂效果，如一些3d变换，页面滚动，或者使用z-index进行z轴排序等，为了更加方便的实现这类效果，渲染引擎还需要为特定节点生成专用的图层，并生成一颗对应的图层树。

         1. 拥有层叠上下文属性的元素会被提升为单独的一层 z-index
         2. 需要剪裁的地方也被创建为图层 文本溢出

      7. ##### 图层绘制

      8. ##### 栅格化操作

         绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。![image-20200725150905560](C:\Users\22\Desktop\笔记\images\image-渲染.png)

         1. 当图层的绘制列表准备好后，主线程会把该绘制列表**提交**给合成线程。

         2. 合成线程将图层划分为图块，之后按照视口附近的图块来优先生成位图，实际上生成位图的操作是由栅格化来执行的。栅格化是指将图块转换为位图。图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有图形栅格化都是在线程池内执行的，运作方式如下：![image-20200725151314953](C:\Users\22\Desktop\笔记\images\image-栅格化.png)

         3. 栅格化过程会使用GPU进行加速生成，使用GPU生成位图的过程叫做快速栅格化，生成的位图被保存在GPU内存中。

         4. 因为GPU操作是在GPU进程中完成，如歌栅格化过程使用了GPU，那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作![image-20200725151632246](C:\Users\22\Desktop\笔记\images\image-GPU栅格化.png)渲染进程把⽣成图块的指令发送给GPU，然后在GPU中执⾏⽣成图块的位图，并保存在 GPU的内存中。 

         5. 合成和显示

            ⼀旦所有图块都被光栅化，合成线程就会⽣成⼀个绘制图块的命令----“DrawQuad”，然后将该命令提交 给浏览器进程。 浏览器进程⾥⾯有⼀个叫viz的组件，⽤来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命 令，将其页面内容绘制到内存中，最后再将页面内容显示在屏幕上。

      9. ##### 渲染流程总结

         ![image-20200725152027066](C:\Users\22\Desktop\笔记\images\image-渲染流程总结.png)

         1. 渲染进程将HTML内容转换为能够读懂的DOM树结构。
         2. 渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。
         3. 创建布局树，并计算元素的布局信息。
         4. 对布局树进行分层，并生成分层树。
         5. 为每个图层生成绘制列表，并将其提交到合成线程。
         6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
         7. 合成线程发送绘制图块命令DrawQuad给浏览器进程。
         8. 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上。

   7. #### 重排、重绘、合成的概念

      1. ##### 更改了元素的几何属性 --- 重排

         ![image-20200725154313363](C:\Users\22\Desktop\笔记\images\image-重排.png)

         如果使用JavaScript或者CSS修改了元素的几何位置属性，如改变元素高度、宽度等，浏览器会触发重新布局，解析之后一系列的子阶段，这个过程被称为重拍。重拍需要更新完整的渲染流水线，所以开销也是最大的。

      2. ##### 更新元素的绘制属性 ---重绘

         例如通过JavaScript更新某些元素的背景颜色。

         ![image-20200725154552964](C:\Users\22\Desktop\笔记\images\image-重绘.png)

         如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为没有引起几何位置的变化，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率比重拍操作要高一些。

      3. ##### 直接合成阶段

         如果更改一个不需要布局也不需要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程称为合成。

         ![image-20200725154907935](C:\Users\22\Desktop\笔记\images\image-直接合成.png)

         在上图中，我们使用了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制的两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

   8. #### 变量提升

      1. JavaScript代码执行过程中，需要先做变量提升，而之所以需要变量提升，是因为JavaScript执行之前需要先编译。
      2. 在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为undefined；在代码执行阶段，JavaScript引擎会从变量环境中去查找自定义的变量和函数。
      3. 如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义那个，这是因为后定义的会覆盖掉之前定义的。

   9. #### 调用栈

      这部分建议观看冴羽老师博客 --- <a style="color:#666" href="https://github.com/mqyqingfeng/Blog">传送门</a>

   10. #### 块级作用域

       1. let 执行上下文

          ![image-20200725204428572](C:\Users\22\Desktop\笔记\images\image-let执行上下文.png)

          1. 编译并创建执行上下文
             1. 函数内部通过var生命的变量，在编译阶段全都被存放到变量环境中。
             2. 通过let生命的变量，在编译阶段会被存放到词法环境中。
             3. 在函数的作用域内部，通过let声明的变量并没有被存放到词法环境中。
          2. 继续执行代码，当执行到代码块里，变量环境中的a的值已经被设置成了1，此法环境中的值已经被设置成了2。
          3. 当进入函数的作用域时，作用域块中通过let声明的变量，会被存放在词法环境一个单独的区域当中，这个区域的变量并不影响作用域块外面的变量，当执行到作用域内部时，同名变量都是单独的存在。
          4. 在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压倒栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。
          5. 当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量a的值，具体查找方式是：沿着词法环境的栈顶向下查询，如果在此法环境中的某个块查到了，就直接返回给JavaScript引擎，如果没有查到，那么就继续在变量环境中查找。![image-20200725210000665](C:\Users\22\Desktop\笔记\images\image-变量环境查找.png)
          6. 当作用域块执行完成之后，其内部定义的变量就会从词法环境的栈顶弹出。

   11. #### 作用域链和闭包

       1. ##### 作用域链

          ![image-20200725215113321](C:\Users\22\Desktop\笔记\images\image-执行上下文案例.png)

          1. 每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。
          2. 当一段代码使用了一个变量时，JavaScript引擎首先会在“当前的执行上下文”中查找该变量，比如上面那段代码在查找myName变量时，如果在当前的变量环境中没有查找到，那么JavaScript引擎会继续在outer所指向的执行上下文中查找。![image-20200725215154332](C:\Users\22\Desktop\笔记\images\image-作用域链.png)
          3. 从图中可以看出，bar函数和foo函数的outer都是指向全局上下文的，这就意味着如果在bar函数或者foo函数中使用了外部变量，那么JavaScript引擎就会去全局执行上下文中查找，我们把这个查找的链条就称为作用域链。

       2. ##### 词法作用域

          词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

          ![image-20200725215712176](C:\Users\22\Desktop\笔记\images\image-词法作用域.png)

          1. 词法作用域就是根据代码的位置来决定的，其中main函数包含了bar函数，bar函数包含了foo函数，所以整个词法作用域的顺序是：foo函数作用域--bar函数作用域--main函数作用域--全局作用域。
          2. 根据词法作用域，foo和bar的上级作用域都是全局作用域，所以如果foo或bar使用了一个它们没有定义的变量，那么它们回到全局作用域去查找。也就是说：**词法作用域是代码阶段就定义好的，和函数怎么调用没有关系。**

       3. ##### 块级作用域中的变量查找

          ![image-20200725221127910](C:\Users\22\Desktop\笔记\images\image-块级作用域的变量查找.png)

          1. 首先在bar的作用域中查找，检查词法环境，检查变量环境
          2. 在全局作用域查找，检查词法环境，检查变量环境![image-20200725221310262](C:\Users\22\Desktop\笔记\images\image-块级作用域变量查找.png)

       4. ##### 闭包

          在JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。

       5. ##### 闭包回收

          1. 通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但是如果这个闭包以后不再使用的话，就会造成内存泄漏。
          2. 如果引用闭包的函数是个局部变量，等函数销毁后，在下次JavaScript引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么JavaScript引擎的垃圾回收器就会回收这块内存。

   12. #### this

       1. 当函数作为对象的方法调用时，函数中的this就是该对象。
       2. 当函数被正常调用时，在严格模式下，this的值是undefined，非严格模式下this指向是全局对象window。
       3. 嵌套函数中的this不会继承外部函数中的this。
       4. 构造函数创建的实例对象，this指向new出来的对象。
       5. call apply bind可以改变this指向。

   13. #### 堆栈空间与数据存储

       1. ##### 栈内存

          1. 原始类型的数据都是直接保存在“栈”中的，引用类型数据的值是存放在“堆”中的。
          2. JavaScript引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了的话，所有的数据都存储在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。例如一个函数执行完成之后，JavaScript引擎需要离开当前执行的上下文，只需要将指针移动到上个上下文的地址就可以了，之前函数的执行上下文栈空间被全部回收。![image-20200725235627534](C:\Users\22\Desktop\笔记\images\image-栈空间回收.png)