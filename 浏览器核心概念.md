1. #### 进程和线程

   1. ##### 进程：
      
      1. 应用程序运行时，操作系统给其动态划分的一块内存空间，用来存放代码、运行中的数据和一个执行任务的主线程，我们称这样的一个运行环境为进程。
      2. 一个进程就是一个应用程序运行的实例。
   2. ##### 线程是进程的一部分
      
      1. 线程是依附于进程的，进程中使用多线程能够提升运行效率
      2. 进程中任一线程的崩溃都会导致进程的崩溃
      3. 线程之间共享进程中的数据
      4. 当一个进程关闭之后，操作系统会回收进程占用的内存
      5. 进程之间的内容相互隔离

2. #### 单进程浏览器时代

   1. ##### 浏览器所有功能模块都是运行在同一个进程里
      
      1. 浏览器上任一线程崩溃都会导致浏览器进程崩溃
      2. 页面渲染，网络请求，JavaScript运行环境，插件都是运行在一个线程中的，不稳定性增大
      3. 线程间数据是共享的，如果有第三方插件窃取数据，浏览器安全性较差

3. #### 多进程浏览器时代

   1. ##### 进程分类

      1. 插件进程
      2. 渲染进程
         1. 解析、渲染、执行JavaScript、合成网页图片
         2. 运行在沙箱里，不能读写硬盘上的数据，不能获取操作系统的读写权限
      3. 浏览器主进程
         1. 下载资源、管理IPC、显示渲染进程生成的图片

   2. ##### 问题解决

      1. 不稳定问题

         1. 进程间相互隔离，不同进程无法获取其他进程数据，一个进程崩溃不会牵连其他进程

      2. 不流畅问题

         1. JavaScript是运行在渲染进程中的，当JavaScript死循环时，受影响的仅有当前页面，其他页面在不同的进程中，故不会受到影响
         2. 页面关闭时，相应的渲染进程随之关闭，操作系统进行内存回收，由此解决内存泄漏问题。

      3. 安全问题

         1. 使用安全沙箱，在沙箱中运行的程序无法访问硬盘，也无法去访问系统权限。

   3. ##### 当前架构

      1. 渲染进程
         
         1. 负责进行HTML CSS JS 的渲染执行，每个Tab标签都有单独的渲染进程，都处于沙箱环境下运行。
         
      2. 插件进程
         
         1. 负责插件的运行，进行插件环境的隔离，避免插件崩溃影响浏览器渲染
         
      3. 网络进程
         
         1. 负责页面网络资源的加载
         
      4. 浏览器主进程
         
         1. 界面显示、用户交互、子进程管理，提供存储等功能
         
      5. GPU 进程
         
         1. 3D图形绘制
         
      6. ###### 存在问题

         1. 更高的资源占用，每个进程都会包含公共基础结构的副本，如JavaScript运行环境
         2. 更复杂的体系结构，浏览器各模块间耦合性高，现有架构很难去支持新特性，适应新需求

   4. ##### 面向未来的架构

      1. 将原先的模块重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须采用预定义好的接口，通过IPC来通信，从而构建一个**更内聚、低耦合、易于维护和拓展的系统**
      2. chrome面向服务的架构图，现在已经实现了一部分![image-20200724201640024](C:\Users\22\Desktop\笔记\images\image-chrome面向服务的架构图.png)

   5. #### TCP/UDP/IP

      1. ##### IP

         1. IP协议位于网络层，接收上层传下来的数据并加上IP头，IP头包含了目的主机的信息和发送方的信息

      2. ##### HTTP

         1. HTTP协议位于应用层，将接受的信息传递到网络层

      3. ##### TCP/UDP

         1. TCP/UDP位于传输层，将HTTP报文加上TCP/UDP首部之后传递到网络层，网络层IP协议再再此基础上加上IP首部

   6. #### 浏览器渲染的几个阶段

      1. 加载HTML、JavaScript、CSS

      2. 渲染流水线

         1. 构建dom树
         2. 样式计算
         3. 布局阶段
         4. 分层
         5. 绘制
         6. 光栅化
         7. 合成

      3. ##### 构建dom树

         1. 构建dom树的输入内容是HTML文本，由HTML解析器解析，最终输出的是树状的dom

      4. ##### 样式计算

         目的是计算出每个dom节点的具体样式

         1. 将CSS转换为浏览器能够理解的结构styleSheets
         2. 转换样式表中的属性值，使其标准化
         3. 计算出dom树中每个节点的具体样式

      5. ##### 布局阶段

         计算dom树中可见元素的几何位置

         1. 创建只包含可见元素的布局树
         2. 布局计算

      6. ##### 分层

         因为页面中还包含有很多的复杂效果，如一些3d变换，页面滚动，或者使用z-index进行z轴排序等，为了更加方便的实现这类效果，渲染引擎还需要为特定节点生成专用的图层，并生成一颗对应的图层树。

         1. 拥有层叠上下文属性的元素会被提升为单独的一层 z-index
         2. 需要剪裁的地方也被创建为图层 文本溢出

      7. ##### 图层绘制

      8. ##### 栅格化操作

         绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。![image-20200725150905560](C:\Users\22\Desktop\笔记\images\image-渲染.png)

         1. 当图层的绘制列表准备好后，主线程会把该绘制列表**提交**给合成线程。

         2. 合成线程将图层划分为图块，之后按照视口附近的图块来优先生成位图，实际上生成位图的操作是由栅格化来执行的。栅格化是指将图块转换为位图。图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有图形栅格化都是在线程池内执行的，运作方式如下：![image-20200725151314953](C:\Users\22\Desktop\笔记\images\image-栅格化.png)

         3. 栅格化过程会使用GPU进行加速生成，使用GPU生成位图的过程叫做快速栅格化，生成的位图被保存在GPU内存中。

         4. 因为GPU操作是在GPU进程中完成，如歌栅格化过程使用了GPU，那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作![image-20200725151632246](C:\Users\22\Desktop\笔记\images\image-GPU栅格化.png)渲染进程把⽣成图块的指令发送给GPU，然后在GPU中执⾏⽣成图块的位图，并保存在 GPU的内存中。 

         5. 合成和显示

            ⼀旦所有图块都被光栅化，合成线程就会⽣成⼀个绘制图块的命令----“DrawQuad”，然后将该命令提交 给浏览器进程。 浏览器进程⾥⾯有⼀个叫viz的组件，⽤来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命 令，将其页面内容绘制到内存中，最后再将页面内容显示在屏幕上。

      9. ##### 渲染流程总结

         ![image-20200725152027066](C:\Users\22\Desktop\笔记\images\image-渲染流程总结.png)

         1. 渲染进程将HTML内容转换为能够读懂的DOM树结构。
         2. 渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。
         3. 创建布局树，并计算元素的布局信息。
         4. 对布局树进行分层，并生成分层树。
         5. 为每个图层生成绘制列表，并将其提交到合成线程。
         6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
         7. 合成线程发送绘制图块命令DrawQuad给浏览器进程。
         8. 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上。

   7. #### 重排、重绘、合成的概念

      1. ##### 更改了元素的几何属性 --- 重排

         ![image-20200725154313363](C:\Users\22\Desktop\笔记\images\image-重排.png)

         如果使用JavaScript或者CSS修改了元素的几何位置属性，如改变元素高度、宽度等，浏览器会触发重新布局，解析之后一系列的子阶段，这个过程被称为重拍。重拍需要更新完整的渲染流水线，所以开销也是最大的。

      2. ##### 更新元素的绘制属性 ---重绘

         例如通过JavaScript更新某些元素的背景颜色。

         ![image-20200725154552964](C:\Users\22\Desktop\笔记\images\image-重绘.png)

         如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为没有引起几何位置的变化，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率比重拍操作要高一些。

      3. ##### 直接合成阶段

         如果更改一个不需要布局也不需要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程称为合成。

         ![image-20200725154907935](C:\Users\22\Desktop\笔记\images\image-直接合成.png)

         在上图中，我们使用了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制的两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

   8. #### 变量提升

      1. JavaScript代码执行过程中，需要先做变量提升，而之所以需要变量提升，是因为JavaScript执行之前需要先编译。
      2. 在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为undefined；在代码执行阶段，JavaScript引擎会从变量环境中去查找自定义的变量和函数。
      3. 如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义那个，这是因为后定义的会覆盖掉之前定义的。

   9. #### 调用栈

      这部分建议观看冴羽老师博客 --- <a style="color:#666" href="https://github.com/mqyqingfeng/Blog">传送门</a>

   10. #### 块级作用域

       1. let 执行上下文

          ![image-20200725204428572](C:\Users\22\Desktop\笔记\images\image-let执行上下文.png)

          1. 编译并创建执行上下文
             1. 函数内部通过var生命的变量，在编译阶段全都被存放到变量环境中。
             2. 通过let生命的变量，在编译阶段会被存放到词法环境中。
             3. 在函数的作用域内部，通过let声明的变量并没有被存放到词法环境中。
          2. 继续执行代码，当执行到代码块里，变量环境中的a的值已经被设置成了1，此法环境中的值已经被设置成了2。
          3. 当进入函数的作用域时，作用域块中通过let声明的变量，会被存放在词法环境一个单独的区域当中，这个区域的变量并不影响作用域块外面的变量，当执行到作用域内部时，同名变量都是单独的存在。
          4. 在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压倒栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。
          5. 当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量a的值，具体查找方式是：沿着词法环境的栈顶向下查询，如果在此法环境中的某个块查到了，就直接返回给JavaScript引擎，如果没有查到，那么就继续在变量环境中查找。![image-20200725210000665](C:\Users\22\Desktop\笔记\images\image-变量环境查找.png)
          6. 当作用域块执行完成之后，其内部定义的变量就会从词法环境的栈顶弹出。

   11. #### 作用域链和闭包

       1. ##### 作用域链

          ![image-20200725215113321](C:\Users\22\Desktop\笔记\images\image-执行上下文案例.png)

          1. 每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。
          2. 当一段代码使用了一个变量时，JavaScript引擎首先会在“当前的执行上下文”中查找该变量，比如上面那段代码在查找myName变量时，如果在当前的变量环境中没有查找到，那么JavaScript引擎会继续在outer所指向的执行上下文中查找。![image-20200725215154332](C:\Users\22\Desktop\笔记\images\image-作用域链.png)
          3. 从图中可以看出，bar函数和foo函数的outer都是指向全局上下文的，这就意味着如果在bar函数或者foo函数中使用了外部变量，那么JavaScript引擎就会去全局执行上下文中查找，我们把这个查找的链条就称为作用域链。

       2. ##### 词法作用域

          词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

          ![image-20200725215712176](C:\Users\22\Desktop\笔记\images\image-词法作用域.png)

          1. 词法作用域就是根据代码的位置来决定的，其中main函数包含了bar函数，bar函数包含了foo函数，所以整个词法作用域的顺序是：foo函数作用域--bar函数作用域--main函数作用域--全局作用域。
          2. 根据词法作用域，foo和bar的上级作用域都是全局作用域，所以如果foo或bar使用了一个它们没有定义的变量，那么它们回到全局作用域去查找。也就是说：**词法作用域是代码阶段就定义好的，和函数怎么调用没有关系。**

       3. ##### 块级作用域中的变量查找

          ![image-20200725221127910](C:\Users\22\Desktop\笔记\images\image-块级作用域的变量查找.png)

          1. 首先在bar的作用域中查找，检查词法环境，检查变量环境
          2. 在全局作用域查找，检查词法环境，检查变量环境![image-20200725221310262](C:\Users\22\Desktop\笔记\images\image-块级作用域变量查找.png)

       4. ##### 闭包

          在JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。

       5. ##### 闭包回收

          1. 通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但是如果这个闭包以后不再使用的话，就会造成内存泄漏。
          2. 如果引用闭包的函数是个局部变量，等函数销毁后，在下次JavaScript引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么JavaScript引擎的垃圾回收器就会回收这块内存。

   12. #### this

       1. 当函数作为对象的方法调用时，函数中的this就是该对象。
       2. 当函数被正常调用时，在严格模式下，this的值是undefined，非严格模式下this指向是全局对象window。
       3. 嵌套函数中的this不会继承外部函数中的this。
       4. 构造函数创建的实例对象，this指向new出来的对象。
       5. call apply bind可以改变this指向。

   13. #### 堆栈空间与数据存储

       1. ##### 栈内存

          1. 原始类型的数据都是直接保存在“栈”中的，引用类型数据的值是存放在“堆”中的。
          2. JavaScript引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了的话，所有的数据都存储在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。例如一个函数执行完成之后，JavaScript引擎需要离开当前执行的上下文，只需要将指针移动到上个上下文的地址就可以了，之前函数的执行上下文栈空间被全部回收。![image-20200725235627534](C:\Users\22\Desktop\笔记\images\image-栈空间回收.png)
          3. 所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆内存空间很大，缺点是分配内存和回收内存会占用一定的时间。
          4. 原始类型的赋值会完整复制变量值，引用类型的赋值是赋值引用地址。

       2. ##### 闭包

          ```js
          function foo(){
              var myName =  'hello'
              let test1 = 1
              const test2 = 2
              var innerBar = {
                  setName : function(){
                      console.log(test1)
                      return myName
                  },
                  getName : function(){
                      console.log(test1)
                      return myName
                  }
              }
              return innerBar
          }
          var bar = foo()
          bar.setName('aaa')
          bar.getName()
          console.log(bar.getName())
          ```

          

          1. 当JavaScript引擎执行到foo函数时，首先会编译，并创建一个空执行上下文。
          2. 在编译过程中，遇到内部函数setName，JavaScript引擎还要堆内部函数做一次快速的词法扫描，发现该内部函数引用了foo函数中的myName变量，由于是内部函数引用了外部函数的变量，所以JavaScript引擎判断这是一个闭包，于是在堆内存空间创建一个“closure(foo)”对象（这是一个内部对象，JavaScript是无法访问的），用来保存myName变量。
          3. 接着继续扫描到getName方法时，发现该函数内部还引用变量test1，于是JavaScript引擎又将test1添加到“closure(foo)”对象中。这时候堆内存中的“closure(foo)”对象中就包含了myName和test1两个变量。
          4. 由于test2并没有被函数引用，所以test2依然保存在调用栈中。![image-20200726002203949](C:\Users\22\Desktop\笔记\images\image-闭包产生过程.png)
          5. 当执行到foo函数时，闭包就产生了；当foo函数执行结束之后，返回的getName和setName方法都引用“closure(foo)”对象，所以即使foo函数退出了，“closure(foo)”依然被其内部的getName和setName方法引用。所以在下次调用bar.setName或者bar.getName时，创建的执行上下文中就包含了“closure(foo)”。
          6. 总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二部是把内部函数引用的外部变量保存到堆中。

   14. #### 垃圾回收 ----栈内存回收

       ```js
       // 以如下代码为例
       function foo(){
           var a = 1
           var b = {name:'极客邦'}
           function showName(){
               var c = '极客时间'
               var d = {name:'极客时间'}
           }
           showName()
       }
       foo()
       ```

       

       1. 当执⾏到第6⾏代码时，其调⽤栈和堆空间状态图如下所示：![image-20200726153018380](C:\Users\22\Desktop\笔记\images\image-堆栈示意图.png)

       2. 从图中可以看出，原始类型的数据被分配到栈中，引用类型的数据会被分配到队中。当foo函数执行结束之后，foo函数的执行上下文会从堆中被销毁掉。

          ​	如果执行到showName函数时，那么JavaScript引擎会创建showName函数的执行上下文，并将showName函数的执行上下文压入到调用栈中，最终执行到showName函数时，其调用栈就如上图所示。与此同时还有一个**记录当前执行状态的指针（称为ESP）**指向调用栈中showName函数的执行上下文，表示当前正在执行的showName函数。

          ​	当showName函数执行完成之后，函数执行流程就进入了foo函数，这时就需要销毁showName函数的执行上下文。JavaScript会将ESP下移到foo函数的执行上下文，**这个下移操作就是销毁showName函数执行上下文的过程。**

          ![image-20200726153615921](C:\Users\22\Desktop\笔记\images\image-函数执行上下文销毁.png)

          从图中可以看出，当showName函数执行结束之后，ESP向下移动到foo函数的执行上下文中，上面showName的执行上下文虽然保存在栈内存中，但已经是无效内存了。比如当foo函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。

          所以说，当一个函数执行结束之后，**JavaScript引擎会通过下移ESP指针来销毁该函数保存在栈中的执行上下文。**

   15. #### 垃圾回收 ---堆内存回收

       当上面一段代码执行完毕之后，ESP是指向全局上下文的，showName函数和foo函数的执行上下文就处于无效状态了，不过保存在堆内存中的两个对象依然占用着空间，如下图所示：![image-20200726154110018](C:\Users\22\Desktop\笔记\images\image-foo函数执行完成后的内存状态.png)

       **要回收这一部分内存，就需要用到JavaScript中的垃圾回收器。**

       1. ##### 代际假说和分代收集

          1. ###### 代际假说有以下两个特点：

             1. 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就不可访问。
             2. 第二个是不死的对象，会活的更久。

          2. ###### 在v8引擎中，会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的是生存时间久的对象。

             1. 新生区通常只支持1-8M的容量，老生代的容量就大很多了。对于这两块区域，V8分别使用两个不同的垃圾回收器，以便更高效的实施垃圾回收。
             2. 副垃圾回收器，主要负责新生代的垃圾回收。
             3. 主垃圾回收器，主要负责老生代的垃圾回收。

       2. ##### 垃圾回收器的工作流程

          **不管是什么类型的垃圾回收器，它们都有一套共同的执行流程。**

          1. 标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
          2. 回收非活动对象占用的内存。其实就是在标记完成之后，统一清理内存中所有被标记为可回收的对象。
          3. 做内存整理。一般来说，频繁回收对象之后，内存中会存在大量不连续空间，我们把这些不连续的内存空间称为**内存碎片**。