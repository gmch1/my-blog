1. ##### 一个对象的创建

   1. 创建对象
   2. 绑定原型
   3. 修改this指向为自身
   4. 判断对象类型，根据类型决定返回结果

2. #### setTimeout 实现

   浏览器事件循环系统

   1. 当接收到HTML文档数据，渲染引擎就会将”解析DOM“事件添加到消息队列中。
   2. 当用户改变了Web页面的窗口大小，渲染引擎就会将”重新布局“的事件添加到消息队列中。
   3. 当触发了JavaScript引擎垃圾回收机制，渲染引擎会将”垃圾回收“任务添加到消息队列中。
   4. 同样，如果要执行一段异步JavaScript代码，也是需要将执行任务添加到消息队列中。

   在chrome中，除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和Chromium内部一些需要延迟执行的任务。所以当通过JavaScript创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。

   1. 如果当前任务执行时间过久，会影响定时器任务的执行
   2. 如果setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为4毫秒
   3. 未激活的页面，setTimeout 执行最小间隔是1000毫秒
   4. setTimeout 延时执行时间有最大值
   5. 使用setTimeout 设置的回调函数中的this指向默认为全局
   6. **requestAnimationFrame** 对比 setTimeout 的优势，setTimeout 即使设置了16.6毫秒，实际执行时间也可能会因为任务阻塞而超时，造成动画效果掉帧，**requestAnimationFrame** 中的回调函数是在页面刷新之前执行，跟着屏幕的刷新率在走，保证每个刷新间隔只执行一次，如果页面未激活的话，**requestAnimationFrame** 也会停止渲染，保证页面的流畅度，又节省主线程执行函数的开销。

3. ##### XMLHttpRequest实现

   1. setTimeout是直接将延迟任务添加到延迟队列当中，而XMLHttpRequest发起请求，是由浏览器的其他进程或线程去执行，然后再将执行结果利用IPC的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列当中。

4. #### 宏任务微任务

   1. ##### 宏任务

      1. 渲染事件（解析DOM、计算布局、绘制）

      2. 用户交互事件（鼠标点击、滚动页面、放大缩小）

      3. JavaScript脚本执行事件

      4. 网络请求完成、文件读写完成事件

         为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个for循环，不断地从这些任务队列中取出任务并执行任务。这些在消息队列中的任务被称为宏任务。

   2. ##### 事件循环机制定义

      1. 先从多个消息队列中选出一个最老的任务，这个任务被称为oldestTask
      2. 然后循环系统记录任务开始执行的时间，并把这个oldestTask设置为当前正在执行的任务
      3. 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个oldestTask
      4. 最后统计执行完成的时长等信息

   3. ##### 微任务

      异步回调主要有两种方式

      1. 把异步回调封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。
      2. 在主函数执行结束之后，当前宏任务结束之前执行回调函数，这通常是以微任务形式体现的。

      **微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前。**

      当JavaScript执行一段脚本的时候，V8会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8引擎也会在内部创建一个**微任务队列**，这个微任务队列就是用来存放微任务的，这个微任务队列是给V8引擎内部使用的，所以无法通过JavaScript直接访问。

      也就是说每个宏任务都关联了一个微任务队列。

      微任务的产生有两种方式

      一种是使用MutationObserver来监控某个DOM节点，然后使用JavaScript来修改这个节点，当DOM节点发生变化时，就会产生DOM变化记录的微任务。

      第二种方式是使用promise，当调用promise.resolve()或者reject的时候，也会产生微任务。

      通过DOM节点变化产生的微任务或者使用Promise产生的微任务都会被JavaScript引擎按照顺序保存到微任务队列中。

      通常情况下，在当前宏任务中的JavaScript快执行完成时，也就是JavaScript引擎准备推出全局执行上下文并清空调用栈的时候，JavaScript引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。

      如果在执行微任务的过程中产生了新的微任务，同样会将该任务添加到微任务队列中，V8引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。![image-20200726234801723](C:\Users\22\Desktop\笔记\images\image-宏任务微任务流程示意图.png)

      1. 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
      2. 微任务的执行时长会影响当前宏任务的时长。
      3. 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。

