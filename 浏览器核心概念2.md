1. ##### 一个对象的创建

   1. 创建对象
   2. 绑定原型
   3. 修改this指向为自身
   4. 判断对象类型，根据类型决定返回结果

2. #### setTimeout 实现

   浏览器事件循环系统

   1. 当接收到HTML文档数据，渲染引擎就会将”解析DOM“事件添加到消息队列中。
   2. 当用户改变了Web页面的窗口大小，渲染引擎就会将”重新布局“的事件添加到消息队列中。
   3. 当触发了JavaScript引擎垃圾回收机制，渲染引擎会将”垃圾回收“任务添加到消息队列中。
   4. 同样，如果要执行一段异步JavaScript代码，也是需要将执行任务添加到消息队列中。

   在chrome中，除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和Chromium内部一些需要延迟执行的任务。所以当通过JavaScript创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。

   1. 如果当前任务执行时间过久，会影响定时器任务的执行
   2. 如果setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为4毫秒
   3. 未激活的页面，setTimeout 执行最小间隔是1000毫秒
   4. setTimeout 延时执行时间有最大值
   5. 使用setTimeout 设置的回调函数中的this指向默认为全局
   6. **requestAnimationFrame** 对比 setTimeout 的优势，setTimeout 即使设置了16.6毫秒，实际执行时间也可能会因为任务阻塞而超时，造成动画效果掉帧，**requestAnimationFrame** 中的回调函数是在页面刷新之前执行，跟着屏幕的刷新率在走，保证每个刷新间隔只执行一次，如果页面未激活的话，**requestAnimationFrame** 也会停止渲染，保证页面的流畅度，又节省主线程执行函数的开销。

3. ##### XMLHttpRequest实现

   1. setTimeout是直接将延迟任务添加到延迟队列当中，而XMLHttpRequest发起请求，是由浏览器的其他进程或线程去执行，然后再将执行结果利用IPC的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列当中。

4. #### 宏任务微任务

   1. ##### 宏任务

      1. 渲染事件（解析DOM、计算布局、绘制）

      2. 用户交互事件（鼠标点击、滚动页面、放大缩小）

      3. JavaScript脚本执行事件

      4. 网络请求完成、文件读写完成事件

         为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个for循环，不断地从这些任务队列中取出任务并执行任务。这些在消息队列中的任务被称为宏任务。

   2. ##### 事件循环机制定义

      1. 先从多个消息队列中选出一个最老的任务，这个任务被称为oldestTask
      2. 然后循环系统记录任务开始执行的时间，并把这个oldestTask设置为当前正在执行的任务
      3. 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个oldestTask
      4. 最后统计执行完成的时长等信息

   3. ##### 微任务

      异步回调主要有两种方式

      1. 把异步回调封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。
      2. 在主函数执行结束之后，当前宏任务结束之前执行回调函数，这通常是以微任务形式体现的。

      **微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前。**

      当JavaScript执行一段脚本的时候，V8会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8引擎也会在内部创建一个**微任务队列**，这个微任务队列就是用来存放微任务的，这个微任务队列是给V8引擎内部使用的，所以无法通过JavaScript直接访问。

      也就是说每个宏任务都关联了一个微任务队列。

      微任务的产生有两种方式

      一种是使用MutationObserver来监控某个DOM节点，然后使用JavaScript来修改这个节点，当DOM节点发生变化时，就会产生DOM变化记录的微任务。

      第二种方式是使用promise，当调用promise.resolve()或者reject的时候，也会产生微任务。

      通过DOM节点变化产生的微任务或者使用Promise产生的微任务都会被JavaScript引擎按照顺序保存到微任务队列中。

      通常情况下，在当前宏任务中的JavaScript快执行完成时，也就是JavaScript引擎准备推出全局执行上下文并清空调用栈的时候，JavaScript引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。

      如果在执行微任务的过程中产生了新的微任务，同样会将该任务添加到微任务队列中，V8引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。![image-20200726234801723](C:\Users\22\Desktop\笔记\images\image-宏任务微任务流程示意图.png)

      1. 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
      2. 微任务的执行时长会影响当前宏任务的时长。
      3. 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。

   4. #### promise

   5. ##### 浏览器解析过程

      1. 在网络进程获取到一个文件时，判断content-type是text、html。则创建渲染进程进行解析，获取startTag并入栈，如果遇到endTag则出栈，碰到script脚本，因为JavaScript可能会修改已经生成的dom，所以DOM解析停止，等待JavaScript执行完成，如果JavaScript中修改了CSS，那么还需要等待CSS加载完成，生成CSSOM树后继续执行。

   6. #### CSS渲染

      ![image-20200727135028610](C:\Users\22\Desktop\笔记\images\image-css渲染.png)

      首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络线程中去执行。网络进程接收到返回的HTML数据后，将其发送给渲染进程，渲染进程会解析HTML数据并构建DOM。**请求HTML数据和构建DOM之间有一段空闲时间，这个空闲时间可能成为页面渲染的瓶颈。**

      当渲染进程接受HTML文件字节流时，会先开启一个预解析线程，如果遇到JavaScript文件或是CSS文件，那么预解析线程会提前下载这些数据。**在CSS文件未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，布局树需要CSSOM 和 DOM，所以这段时间需要等待CSS加载结束并解析生成CSSOM。**

      和HTML一样，渲染引擎也是无法直接理解CSS文件内容，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是CSSOM。和DOM一样，CSSOM也具有两个作用，**一个是提供给JavaScript操作样式表的能力，一个是为布局树的合成提供基础的样式信息。**体现在DOM中就是document.styleSheets。

      等CSSOM和DOM都构建好之后，渲染引擎就会构造布局树。布局树的结构基本上就是复制DOM树的结构，不同之处在于DOM树中不需要显示的元素会被过滤掉。复制好基本的布局树结构之后，渲染引擎会为对应的DOM元素选择对应的样式信息，这个过程就是**样式计算**。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是**计算布局**。通过样式计算和计算布局就完成了最终布局树的构建。之后就开始进行绘制工作。

   7. #### 影响页面展示的因素以及优化策略

      渲染流水线影响到了首次页面展示的速度，首次页面展示的速度又直接影响到了用户体验。

      1. 第一个阶段，等请求发出去之后，到提交数据阶段，这是页面展示出来的还是之前页面的内容。

      2. 第二个阶段，提交数据之后渲染进程会创建一个空白页面，**我们通常会把这段时间称为解析白屏**，并等待CSS文件和JavaScript文件的加载完成，生成CSSOM和DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。

      3. 第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。

         影响第一个阶段的主要因素是网络或者是服务器处理这块而，第二个阶段主要是白屏时间，如果白屏时间过久就会影响到用户体验。这段时间的主要任务有：

         解析HTML、下载CSS、下载JavaScript、生成CSSOM、执行JavaScript、生成布局树、绘制页面一系列操作。

         这个阶段的瓶颈主要体现在**下载CSS文件、下载JavaScript文件和执行JavaScript**。

         所以要缩短白屏时长，可以采用以下策略：

         1. 通过内联JavaScript、内联CSS来移除这两类文件的下载，这样获取到HTML文件之后就可以直接开始渲染流程。
         2. 但不是所有场合都适合内联，所以还可以尽量减少文件大小，比如使用webpack等工具移除一些不必要的注释，并压缩JavaScript文件。
         3. 可以将一些不需要在解析HTML阶段执行的JavaScript标记上async或者defer。
         4. 对于较大的CSS文件，可以通过媒体查询属性，将其拆分成多个不同用途的CSS文件，这样只有在特定场景下才会加载特定的CSS文件。

   8. #### 