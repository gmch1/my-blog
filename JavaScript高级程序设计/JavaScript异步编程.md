### 异步编程

同步行为与异步行为的统一一直是计算机科学的一个基本概念。特别是JavaScript这种单线程事件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。

重要的是，异步操作并不一定计算量大或要等很长时间，只要你不想为某个异步操作而阻塞线程执行，那么任何时候都可以使用。

#### 异步与同步

**同步行为**对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地如（寄存器或内存）的信息。这样的执行流程很容易分析系统在执行到代码任意位置时的状态，比如变量的值。

```js
let x = 3
x = x + 4
```

在程序执行的每一步，都可以推断出程序的状态。这是因为后面的指令总是在前面的指令执行完成后才会执行。等到最后一条执行完毕，存储在x的值就立即可以使用。

首先操作系统会在栈内存上分配一个存储浮点数值的空间，然后根据这个值做一次数学计算，再把计算结果写回之前分配的内存中。所有的这些指令都是再单个线程中按顺序执行的。在低级指令的层面，有充足的工具可以确定系统状态。

相对的**异步行为**类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的。因为强制进程等待一个长时间的操作通常是不可行的，如果代码要访问一些高延迟的资源，比如向远程服务器发起请求并等待响应，那就会出现长时间的等待。

异步操作的例子是可以在定时器回调中执行一次简单的数学计算：

```js
let x = 3
setTimeout(() => x = x + 4, 1000)
```

#### 回调函数

#### promise

##### promise状态机

把一个promise实例传给console.log时，控制台输出表明该实例处于待定状态。如前所述，promise是一个有状态的对象，promise可以处于以下三种状态：

- pending
- fulfilled
- rejected

pending状态是promise的最初状态，在待定状态下，promise可以落定为代表成功的兑现fulfilled状态，或者代表失败的拒绝状态。无论落定为哪种状态都是不可逆的。只要由待定状态落定为兑现态或拒绝态，之后promise的状态就不能发生改变。

promise的状态是私有的，不能直接通过JavaScript检测到。这主要是为了避免根据读取到的promise状态，以同步方式处理异步对象。另外，promise的状态也不能被外部JavaScript代码修改，这与不能读取该状态的原因是一样的，promise故意将异步行为封装起来，从而隔离外部的同步代码。

##### 解决值、拒绝理由及promise用例

promise主要有两大用途，首先是抽象的表示一个异步操作，promise的状态表示promise是否完成。待定表示尚未开始或正在执行中。兑现表示已经成功完成，而拒绝则表示没有成功完成。

某些情况下，这个状态机就是promise可以提供的最有用的信息。知道一段异步代码已经完成，对于其他代码而言已经足够了。

在另外一些情况下，promise封装的异步操作实际上会生成某个值，而程序期待pormise状态改变时可以访问这个值。相应的，如果promise被拒绝，程序就会期待promise状态改变时可以拿到拒绝的理由。

为了支持这两种用例，每个promise只要状态切换为兑现，就会有一个私有的内部值。类似的，每个promise只要状态切换为拒绝，就会有一个私有的内部理由。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为undefined。在promise到达某个落定状态时执行的异步代码始终会收到这个值或理由。

##### 通过执行函数控制promise状态

由于promise的状态是私有的，所以只能在内部进行操作。内部操作在promise的执行器函数中完成。执行器函数主要有两项职责：初始化promise的异步行为和控制状态的最终转换。其中，控制promise状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常命名为resolve reject。调用resolve后状态改变为兑现，调用reject后状态改变为拒绝。此外，调用reject也会抛出错误。

```js
let p1 = new Promise((resolve, reject) => resolve());
setTimeout(console.log, 1000, p1);

let p2 = new Promise((resolve, reject) => reject());
setTimeout(console.log, 1000, p2);
```

在前面的例子中，没有什么异步操作，因为在初始化promise时，执行器函数已经改变了每个promise的状态。这里的关键在于，执行器函数是同步执行的。这是因为执行器函数是promise的初始化程序。通过下面的例子可以看出上面代码的执行顺序。

无论resolve和reject哪个先被调用，之后状态转换都是不可撤销的，于是继续修改状态会静默失败。

##### promise.resolve

promise并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用promise.resolve静态方法，可以实例化一个解决的promise。

下面两个promise实际上是一样的：

```js
let p1 = new Promise((resolve) => resolve());
let p2 = Promise.resolve();
```

把这个解决的promise的值传给promise.resolve的第一个参数。使用这个静态方法，实际上可以把任何一个值都转换成一个promise：

```js

```

对于这个静态方法而言，如果传入的参数本身是一个promise，那它的行为就类似一个空包装。因此，promise.resolve可以说成是一个幂等方法，如下所示：

```js

```

这个静态方法能够包装任何非promise值，包括错误对象，并将其转换为解决的promise。因此，因矿难导致不符合预期的行为：

```js

```

##### Promise.reject

Promise.reject会实例化一个拒绝的promise并抛出一个异步错误，这个错误不能通过try、catch捕获，而且只能通过拒绝处理程序捕获。下面两个拒绝promise实际上是一样的：

```js

```

这个拒绝的promise的理由就是传给reject的第一个参数，这个参数也会传给后续的拒绝处理程序：

```js

```

关键在于，reject并没有照搬resolve的幂等逻辑，如果传给他一个对象，那么这个对象会称为它返回的拒绝promise的理由。

##### 同步、异步执行的二义性

promise是同步对象（在同步模式中使用），但也是异步执行模式的媒介。

#### promise的实例方法



