## Object的变化侦测

在vue.js中，对数组和对象采用了不同的方式进行变化侦测。

### 变化侦测是什么

vue会自动通过状态生成DOM，并将其输出到页面上显示出来，这个过程叫渲染。vue渲染过程是声明式的，我们通过模板来描述状态与DOM之间的关系。

通常，在运行时应用内部的状态会不断地发生变化，此时需要不停的进行重新渲染，变化侦测就是用来解决这个问题的，它分为两种类型，一种是推，一种是拉。

angular和react中的变化侦测都属于拉，当状态变化时，它不知道哪个状态变了，只知道状态可能有变化，然后发送一个信号给框架，框架内部收到信号后，会进行一个暴力比对，来找出哪些DOM节点需要重新渲染。这在angular中是脏检查的流程，在react中是使用虚拟DOM。

vue中的变化侦测属于推，当状态发生变化时，vue立即就知道了，而且在一定程度上知道哪些状态改变了，因此知道的信息更多，也就可以进行更细粒度的更新。

更细粒度的更新是指，假如一个状态绑定多个依赖，在状态发生变化时，就可以向这个状态绑定的所有依赖发送通知，让他们进行DOM更新操作，相比较而言，拉的粒度是最粗的。

相对应，粒度越细，每个状态绑定的依赖就越多，依赖追踪在内存上的开销就越大。因此在vue2.0开始，引入了虚拟DOM，将粒度调整为中等粒度，一个状态所绑定的不再是具体的DOM节点，而是一个组件。状态变化之后，会通知到组件，组件内部再使用虚拟DOM进行比对，这样就可以大大降低依赖数量，从而降低依赖追踪所消耗的内存。

### 如何追踪变化

在JavaScript中，可以使用defineProperty和proxy来实现变化侦测。

使用defineProperty来侦测变化会带来很多缺陷，所以在vue3.0中使用proxy来重写这一部分逻辑。

```js
function defineReactive(data, key, value) {
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      return val;
    },
    set: function (newValue) {
      if (val === newValue) {
        return;
      }
      val = newValue;
    },
  });
}
```

这里的函数defineReactive用来对  Object.defineProperty进行封装，作用是定义一个响应式数据，也就是在这个函数中进行变化追踪，封装好只需要传递data、key、value即可。

### 如何收集依赖

_在vue2.0中，模板使用数据等同于组件使用数据，所以当数据发生变化时，会将通知发送到组件，然后组件内部再通过虚拟DOM重新渲染。_

##### 在getter中收集依赖，在setter中触发依赖

### 依赖收集在哪里

给每一个key一个数组，用来存储当前key的依赖，假设依赖是一个函数，保存在window.target上，由此改造defineReactive

```js
function defineReactive(data, key, value) {
  let dep = []; // 保存依赖的数组
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      dep.push(window.target); // 将依赖保存
      return val;
    },
    set: function (newValue) {
      if (val === newValue) {
        return;
      }
      for (let i = 0; i < dep.length; i++) {
        dep[i](newValue, val); // 循环触发依赖
      }
      val = newValue;
    },
  });
}
```

将依赖收集的代码封装成一个Dep类，帮助我们管理依赖，实现依赖收集、删除依赖或向依赖发送通知等功能。

```js
export default class Dep {
  constructor() {
    this.subs = [];
  }
  addSub(sub) {
    this.subs.push(sub);
  }
  removeSub(sub) {
    remove(this.subs, sub);
  }
  // 修改
  depend() {
    if (window.target) {
      this.addSub(window.target);
    }
  }
  // 新增
  notify() {
    const subs = this.subs.slice();
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  }
}
function remove(arr, item) {
  if (arr.length) {
    const index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

function defineReactive(data, key, val) {
  let dep = new Dep();
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      dep.depend();
      return val;
    },
    set: function (newVal) {
      if ((val = newVal)) {
        return;
      }
      val = newVal;
      dep.notify();
    },
  });
}

```

### 依赖是什么

在上面代码中，我们收集的依赖是window.target，window.target即我们在依赖变化后通知的对象。

我们在数据发生变化时，需要通知用到这个数据的地方，而使用这个数据的地方有很多，且类型也有不同，既有可能是模板，也有可能是用户写的一个watch，这时需要抽象出来一个能够集中处理这些情况的类。

然后再依赖收集阶段，只收集这个封装好的类的实例进来，通知也只用通知它一个，接着，再由它去通知其他地方，这个类即为Watcher。

#### Watcher是什么

watcher是一个中介角色，数据发生变化时通知它，然后它再通知其他地方。

```js
// watcher的使用方式
vm.$watch('a,b,c',function(newVal,oldVal){
    // do anything
})
```

这段代码表示，当data.a.b.c属性发生变化时，触发第二个参数中的函数。

实现方式，将watcher实例添加到data.a.b.c属性的Dep中，当值改变时，通知Watcher，再由watcher执行参数中的回调函数。



```JS
export default class watcher {
  constructor(vm, expOrFn, cb) {
    this.vm = vm;
    // 执行this.getter就可以，读取data.a.b.c的内容
    this.getter = parsePath(expOrFn);
    this.cb = cb;
    this.value = this.get();
  }
  get() {
    window.target = this;
    let value = this.getter.call(this.vm, this.vm);
    window.target = undefined;
    return value;
  }
  update() {
    const oldValue = this.value;
    this.value = this.get();
    this.cb.call(this.vm, this.value, oldValue);
  }
}

const bailRe = /[^w.$]/;
export function parsePath(path) {
  if (bailRe.test(path)) {
    return;
  }
  const segments = path.split('.');
  return function (obj) {
    for (let i = 0; i < segments.length; i++) {
      if (!obj) return;
      obj = obj[segments[i]];
    }
    return obj;
  };
}

```

#### 递归侦测所有key

为了把数据中所有属性都侦测到，所以要封装一个Observer类，这个类的作用是将一个数据内的所有属性（包括子属性）都转换成getter/setter的形式，然后去追踪它们的变化。

```js
// Observer类会附加到每一个被侦测的object上
// 一旦被附加上，Observer会将object所有属性都转换为getter/setter的形式
// 来收集依赖，并且当属性变化时，会通知这些依赖
export class Observer {
  constructor(value) {
    this.value = value;
    if (!Array.isArray(value)) {
      this.walk(value);
    }
  }
  // walk会将每一个属性都转换成getter/setter的形式来侦测变化
  // 这个方法只有再数据类型为Object时被调用
  walk(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i], obj[keys[i]]);
    }
  }
}

function defineReactive(data, key, val) {
  // 新增、递归子属性
  if (typeof val === 'object') {
      // 递归子属性
    new Observer(val);
  }
  let dep = new dep();
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      dep.depend();
      return val;
    },
    set: function (newVal) {
      if (val === newVal) {
        return;
      }
      val = newVal;
      dep.notify();
    },
  });
}
```

在上面代码中，我们定义了Observer类，用来将一个正常的object转换成被侦测的object。

然后判断数据类型，只有object类型才会调用walk将每一个属性转换成getter或setter的形式来侦测变化。

最后，在defineReactive中新增new Observer（val)来递归子属性，这样就可以把data中所有的属性都转换成getter/setter的形式来侦测变化。

当data中的属性发生变化时，与这个属性相对应的依赖就会接受到通知。

也就是说，只要我们将一个object传到Observer中，那么这个object就会变成响应式的object。



#### 关于Object的问题

vue.js中，数据变化是通过getter/setter来追踪的,也正是由于这种追踪方式，有些语法中即使数据发生了变化，vue.js也追踪不到。

比如，向object添加属性：

```js
var vm = new Vue({
  el: '#el',
  template: '#demo-template',
  methods: {
    action() {
      this.obj.name = 'berwin';
    },
  },
  data: {
    obj: {},
  },
});
```

action方法中，我们在obj上面新增了name属性，vue.js无法侦测到这个变化，所以不会向依赖发送通知。

例如，从obj中删除一个属性：

```js
var vm = new Vue({
  el: '#el',
  template: '#demo-template',
  methods: {
    action() {
      delete this.obj.name;
    },
  },
  data: {
    obj: {
      name: 'berwin',
    },
  },
});
```

在上面代码中，我们在action方法中删除了obj的name属性，而vue.js无法侦测到这个变化，所以不会向依赖发送通知。

vue.js通过Object.defineProperty来将对象的key转换成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性，所以才导致上面例子中出现的问题。

为了解决这个问题，vue.js提供了两个API，vm.$set、vm.$delete。

#### 总结

变化侦测就是侦测数据的变化，当数据发生变化时，要能侦测到并发出通知。

Object通过defineProperty将属性转换成getter和setter的形式来追踪变化。读取时触发getter，修改时触发setter。

我们需要在getter中收集有哪些依赖使用了数据，当setter触发时，去通知getter中收集的依赖：数据发生了变化。

收集依赖要为依赖找一个存储的地方，为此我们创建了Dep，它用来收集依赖、删除依赖和向依赖发送消息等。

所谓依赖，其实就是watcher。只有watcher触发的getter才会收集依赖，那个watcher触发了依赖，就把你那个watcher收集到dep中，当数据发生变化时，会循环依赖列表，把所有的watcher都通知一遍。

watcher的原理是先把自己设置到全局唯一的指定位置（例如window.target），然后读取数据。因为读取数据，所以会触发这个数据的getter。接着，getter就会从全局唯一的那个位置读取当前正在读取数据的watcher，并把这个watcher收集到Dep当中去。通过这种方式，watcher可以主动去订阅任意一个数据的变化。

此外，我们创建了Observer类，他的作用是把一个object中所有数据（包括子数据）都转换成响应式的，也就是它会侦测object中所有数据（包括子数据）的变化。

由于在ES6之前JavaScript没有提供元编程的能力，所以在对象上新增属性和删除属性都无法被追踪到。

<img src='https://common-fd.zol-img.com.cn//g6//M00//04//0B//ChMkKV8icVmILq_OAACUg8tXyTkAAASxgM4aHgAAJSb497.jpg'/>

Data通过Observer转换成了getter/setter的形式来追踪变化。

当外界通过watcher读取数据时，会触发getter从而将watcher添加到依赖中。

当数据发生了变化时，会触发setter，从而向Dep中的依赖（watcher）发送通知。

Watcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户某个回调函数等。

