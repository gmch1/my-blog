## Object的变化侦测

在vue.js中，对数组和对象采用了不同的方式进行变化侦测。

### 变化侦测是什么

vue会自动通过状态生成DOM，并将其输出到页面上显示出来，这个过程叫渲染。vue渲染过程是声明式的，我们通过模板来描述状态与DOM之间的关系。

通常，在运行时应用内部的状态会不断地发生变化，此时需要不停的进行重新渲染，变化侦测就是用来解决这个问题的，它分为两种类型，一种是推，一种是拉。

angular和react中的变化侦测都属于拉，当状态变化时，它不知道哪个状态变了，只知道状态可能有变化，然后发送一个信号给框架，框架内部收到信号后，会进行一个暴力比对，来找出哪些DOM节点需要重新渲染。这在angular中是脏检查的流程，在react中是使用虚拟DOM。

vue中的变化侦测属于推，当状态发生变化时，vue立即就知道了，而且在一定程度上知道哪些状态改变了，因此知道的信息更多，也就可以进行更细粒度的更新。

更细粒度的更新是指，假如一个状态绑定多个依赖，在状态发生变化时，就可以向这个状态绑定的所有依赖发送通知，让他们进行DOM更新操作，相比较而言，拉的粒度是最粗的。

相对应，粒度越细，每个状态绑定的依赖就越多，依赖追踪在内存上的开销就越大。因此在vue2.0开始，引入了虚拟DOM，将粒度调整为中等粒度，一个状态所绑定的不再是具体的DOM节点，而是一个组件。状态变化之后，会通知到组件，组件内部再使用虚拟DOM进行比对，这样就可以大大降低依赖数量，从而降低依赖追踪所消耗的内存。

### 如何追踪变化

在JavaScript中，可以使用defineProperty和proxy来实现变化侦测。

使用defineProperty来侦测变化会带来很多缺陷，所以在vue3.0中使用proxy来重写这一部分逻辑。

```js
function defineReactive(data, key, value) {
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      return val;
    },
    set: function (newValue) {
      if (val === newValue) {
        return;
      }
      val = newValue;
    },
  });
}
```

这里的函数defineReactive用来对  Object.defineProperty进行封装，作用是定义一个响应式数据，也就是在这个函数中进行变化追踪，封装好只需要传递data、key、value即可。

### 如何收集依赖

_在vue2.0中，模板使用数据等同于组件使用数据，所以当数据发生变化时，会将通知发送到组件，然后组件内部再通过虚拟DOM重新渲染。_

##### 在getter中收集依赖，在setter中触发依赖

### 依赖收集在哪里

给每一个key一个数组，用来存储当前key的依赖，假设依赖是一个函数，保存在window.target上，由此改造defineReactive

```js
function defineReactive(data, key, value) {
  let dep = []; // 保存依赖的数组
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      dep.push(window.target); // 将依赖保存
      return val;
    },
    set: function (newValue) {
      if (val === newValue) {
        return;
      }
      for (let i = 0; i < dep.length; i++) {
        dep[i](newValue, val); // 循环触发依赖
      }
      val = newValue;
    },
  });
}
```

将依赖收集的代码封装成一个Dep类，帮助我们管理依赖，实现依赖收集、删除依赖或向依赖发送通知等功能。

```js
export default class Dep {
  constructor() {
    this.subs = [];
  }
  addSub(sub) {
    this.subs.push(sub);
  }
  removeSub(sub) {
    remove(this.subs, sub);
  }
  // 修改
  depend() {
    if (window.target) {
      this.addSub(window.target);
    }
  }
  // 新增
  notify() {
    const subs = this.subs.slice();
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  }
}
function remove(arr, item) {
  if (arr.length) {
    const index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

function defineReactive(data, key, val) {
  let dep = new Dep();
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      dep.depend();
      return val;
    },
    set: function (newVal) {
      if ((val = newVal)) {
        return;
      }
      val = newVal;
      dep.notify();
    },
  });
}

```

### 依赖是什么

在上面代码中，我们收集的依赖是window.target，window.target即我们在依赖变化后通知的对象。

我们在数据发生变化时，需要通知用到这个数据的地方，而使用这个数据的地方有很多，且类型也有不同，既有可能是模板，也有可能是用户写的一个watch，这时需要抽象出来一个能够集中处理这些情况的类。

然后再依赖收集阶段，只收集这个封装好的类的实例进来，通知也只用通知它一个，接着，再由它去通知其他地方，这个类即为Watcher。

#### Watcher是什么

watcher是一个中介角色，数据发生变化时通知它，然后它再通知其他地方。











