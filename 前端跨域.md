# 前端跨域及解决方案

题记：

​	众所周知，前端跨域在当前已经成为面试的基本考点，本片文章使用最基本的node js 和 JavaScript原生的 XMLHttpRequest 对象来模拟前端跨域的种种场景及解决方案。

##### 初始代码

1. 浏览器端代码

   ```html
   <!DOCTYPE html>
   <html lang="en">
     <head>
       <meta charset="UTF-8" />
       <meta name="viewport" content="width=device-width, initial-scale=1.0" />
       <title>跨域解决方案</title>
     </head>
     <body>
       <script>
         //跨域情况下 发送请求服务器端是收到了，但是返回的数据被浏览器拦截
         let request = new XMLHttpRequest();
         request.onreadystatechange = function () {
           if (request.readyState === 4) {
             console.log(request.responseText);
           }
         };
         request.open('PUT', 'http://localhost:3000/a?bb=222');
         request.send();
       </script>
     </body>
   </html>
   
   ```

   

2. 服务器端代码

```js
const http = require('http');
// 用于进行query数据解析
const queryString = require('querystring');

const server = http.createServer((req, res) => {
  let query = JSON.stringify(queryString.parse(req.url.split('?')[1]));
  console.log(query);
  res.end(query);
});

server.listen(3000);

```

1. ##### 发送get请求、post请求出现跨域

   1. 使用live server打开网页，我们可以看到跨域的提示

      1. 控制栏报错![image-20200719111507827](./images\跨域错误1.png)
      2. network中无返回数据，响应头为304![image-20200719111608085](./images\响应头.png)![image-20200719111645618](./images\响应头无数据.png)
      3. 服务器端已经接收到了数据![image-20200719111735414](./images\服务端接收成功.png)
      4. 由上面几点可以得出结论，跨域情况下请求是已经发送到了服务器端，但是响应被浏览器拦截

   2. ##### get、post请求的CROS处理

      1. 在服务器端加入这段代码

      2. ```js
          res.setHeader('Access-Control-Allow-Origin', '*');
         ```

      3. 浏览器再次进行访问![image-20200719112043596](./images\浏览器访问正常.png)

    3. ##### put、delete请求的CROS处理 

        1. 当前使用put 或delete请求![image-20200719112232580](./images\put、delete请求.png)

        2. 服务器端配置允许的请求方法

        3. ```js
        res.setHeader('Access-Control-Allow-Methods', 'PUT,POST,GET,DELETE,OPTIONS');
           // 允许使用put delete请求进行访问，options是预检请求，用于检测服务器端支持的方法
           ```
   
        4. 响应结果正常![image-20200719112452924](./images\put响应正常.png)
   
   4. ##### 使用jsonp请求的处理
   
      1. jsonp也是一种比较常用的请求方式，原理是使用script标签的跨域特点，来实现get请求
   
      2. 前端代码
   
      3. ```html
      <!DOCTYPE html>
         <html lang="en">
        <head>
             <meta charset="UTF-8" />
             <meta name="viewport" content="width=device-width, initial-scale=1.0" />
             <title>跨域解决方案</title>
           </head>
           <body>
             <script>
               var script = document.createElement('script');
               script.type = 'text/javascript';
               script.src =
                 'http://localhost:3000/api?user=2333&name=6666&callback=func';
               document.head.appendChild(script);
               function func(...args) {
                 console.log(args);
               }
             </script>
           </body>
         </html>
         
         ```
      
      4. 后端代码
      
      5. ```js
         const http = require('http');
         const queryString = require('querystring');
         
         const server = http.createServer((req, res) => {
           const query = queryString.parse(req.url.split('?')[1]);
           const fn = query.callback;
           res.writeHead(200, { 'Content-Type': 'text/javascript' });
           res.write(fn + '(' + JSON.stringify(query) + ')');
           res.end(fn + '(' + JSON.stringify(query) + ')');
         });
         
         server.listen(3000);
         
         ```
      
      
      
      
      
      
      
      
      
      

